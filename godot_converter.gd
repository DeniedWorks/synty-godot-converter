## Synty Shader Converter - FBX to Scene Converter
##
## Extracts individual meshes from FBX files and saves them as .tscn scene files
## with materials as external references (not baked in).
##
## This script is the Godot-side component of the Synty conversion pipeline.
## It reads mesh-to-material mappings generated by the Python tools and
## applies the correct .tres materials to each mesh surface.
##
## Usage:
##   godot --headless --script res://godot_converter.gd
##
## Prerequisites:
##   - res://shaders/mesh_material_mapping.json - Maps mesh names to material name arrays
##     (generated by material_list.py)
##   - Pack folders containing:
##     - models/ - Directory containing FBX files to convert
##     - materials/ - Directory containing .tres material files
##
## Output:
##   - {pack}/meshes/ - Individual .tscn scene files (one per MeshInstance3D found)
##     Each scene has a MeshInstance3D root with material overrides pointing to
##     external .tres files, keeping materials editable and reusable.
##
## Pack Discovery:
##   The script auto-discovers pack folders by looking for directories containing
##   both models/ and materials/ subdirectories at the project root.
##
## Collision Handling:
##   Meshes with "collision" in their name or ending with "_col" are saved
##   with a green wireframe StandardMaterial3D for debugging visibility.
##
## @tutorial(User Guide): docs/user-guide.md
## @tutorial(API Reference): docs/api/godot_converter.md

extends SceneTree

## Maps mesh names to arrays of material names.
## Loaded from res://shaders/mesh_material_mapping.json at startup.
## Keys are mesh names (e.g., "SM_Prop_Crystal_01"), values are
## arrays of material names in surface index order.
## @type Dictionary[String, Array[String]]
var mesh_to_materials: Dictionary = {}

## Tracks mesh names that have been saved to detect duplicates across FBX files.
## Keys are output paths, values are true (just used as a set).
## @type Dictionary[String, bool]
var saved_mesh_names: Dictionary = {}

## Counter for successfully converted and saved meshes.
var meshes_saved: int = 0

## Counter for meshes skipped (null mesh, no surfaces, etc.).
var meshes_skipped: int = 0

## Counter for non-fatal warnings (missing materials, duplicates, etc.).
var warnings: int = 0

## Counter for errors that prevented mesh conversion.
var errors: int = 0

## Magenta material applied to collision meshes for debugging visibility.
## Collision meshes are identified by name containing "collision" or ending with "_col".
var collision_material: StandardMaterial3D = null

## Current pack folder being processed (e.g., "res://PolygonNature_SourceFiles").
## Used for resolving material paths relative to the pack.
var current_pack_folder: String = ""


## Main entry point. Called when script runs via --script flag.
## Orchestrates the complete FBX-to-TSCN conversion process:
## 1. Loads material mapping from JSON
## 2. Discovers pack folders
## 3. For each pack folder:
##    a. Finds all FBX files in {pack}/models/
##    b. Processes each FBX, extracting meshes and applying materials from {pack}/materials/
##    c. Saves scenes to {pack}/meshes/
## 4. Prints summary and exits with appropriate code
func _init() -> void:
	print("=" .repeat(60))
	print("Synty Shader Converter - FBX to Scene Files (.tscn)")
	print("=" .repeat(60))
	print("")

	# Create wireframe material for collision meshes
	collision_material = StandardMaterial3D.new()
	collision_material.albedo_color = Color(0.0, 1.0, 0.0)  # Green wireframe
	collision_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	collision_material.wireframe = true

	# Load the material mapping
	if not load_material_mapping():
		printerr("Failed to load material mapping. Aborting.")
		quit(1)
		return

	# Discover pack folders
	var pack_folders := discover_pack_folders()

	if pack_folders.is_empty():
		print("No pack folders found (directories with models/ and materials/ subdirs)")
		quit(0)
		return

	print("Found %d pack folder(s): %s" % [pack_folders.size(), ", ".join(pack_folders)])
	print("")

	# Process each pack folder
	for pack_folder in pack_folders:
		process_pack_folder(pack_folder)

	print("")
	print_summary()

	# Exit with error code only if no meshes were saved at all
	# Warnings (missing materials, etc.) are expected and shouldn't cause failure
	var exit_code := 0 if meshes_saved > 0 else 1
	quit(exit_code)


## Discovers pack folders at the project root.
## Pack folders are identified by having both models/ and materials/ subdirectories.
## Hidden directories (starting with .) and special directories (.godot, shaders, meshes)
## are skipped.
##
## @returns Array[String] Array of pack folder resource paths (e.g., "res://PackName").
func discover_pack_folders() -> Array[String]:
	var result: Array[String] = []
	var root_dir := DirAccess.open("res://")

	if root_dir == null:
		printerr("Cannot open project root directory")
		return result

	root_dir.list_dir_begin()
	var dir_name := root_dir.get_next()

	while dir_name != "":
		if root_dir.current_is_dir():
			# Skip hidden and special directories
			if not dir_name.begins_with(".") and dir_name != "shaders" and dir_name != "meshes":
				var pack_path := "res://" + dir_name
				var models_path := pack_path + "/models"
				var materials_path := pack_path + "/materials"

				# Check if this is a valid pack folder (has both models and materials)
				if DirAccess.dir_exists_absolute(models_path) and DirAccess.dir_exists_absolute(materials_path):
					result.append(pack_path)

		dir_name = root_dir.get_next()

	root_dir.list_dir_end()
	return result


## Processes a single pack folder, converting all FBX files within it.
##
## @param pack_folder Resource path to the pack folder (e.g., "res://PolygonNature_SourceFiles").
func process_pack_folder(pack_folder: String) -> void:
	print("Processing pack: %s" % pack_folder)
	current_pack_folder = pack_folder

	var models_path := pack_folder + "/models"
	var meshes_output := pack_folder + "/meshes"

	# Ensure output directory exists
	_ensure_directory_exists(meshes_output)

	# Find all FBX files in the pack's models directory
	var fbx_files := find_fbx_files(models_path)

	if fbx_files.is_empty():
		print("  No FBX files found in %s" % models_path)
		return

	print("  Found %d FBX file(s) to process" % fbx_files.size())

	for fbx_path in fbx_files:
		process_fbx_file(fbx_path)


## Loads the mesh-to-material mapping from JSON file.
## The JSON file maps mesh names to arrays of material names.
## This mapping is generated by the Python material_list.py tool.
##
## @returns bool True if loading succeeded, false otherwise.
func load_material_mapping() -> bool:
	const MAPPING_PATH := "res://shaders/mesh_material_mapping.json"

	if not FileAccess.file_exists(MAPPING_PATH):
		printerr("Material mapping file not found: %s" % MAPPING_PATH)
		return false

	var file := FileAccess.open(MAPPING_PATH, FileAccess.READ)
	if file == null:
		printerr("Failed to open mapping file: %s (error: %s)" % [
			MAPPING_PATH,
			error_string(FileAccess.get_open_error())
		])
		return false

	var json_text := file.get_as_text()
	file.close()

	var json := JSON.new()
	var parse_result := json.parse(json_text)

	if parse_result != OK:
		printerr("Failed to parse JSON: %s at line %d" % [
			json.get_error_message(),
			json.get_error_line()
		])
		return false

	var data = json.get_data()
	if not data is Dictionary:
		printerr("Invalid mapping format: expected Dictionary, got %s" % typeof(data))
		return false

	mesh_to_materials = data
	print("Loaded material mapping with %d mesh entries" % mesh_to_materials.size())

	return true


## Recursively finds all FBX files in the given directory.
## Searches subdirectories and returns paths to all .fbx files found.
## Hidden directories (starting with .) are skipped.
##
## @param dir_path Resource path to search (e.g., "res://PackName/models").
## @returns Array[String] Array of FBX file paths found.
func find_fbx_files(dir_path: String) -> Array[String]:
	var result: Array[String] = []
	var dir := DirAccess.open(dir_path)

	if dir == null:
		push_warning("Cannot open directory: %s (error: %s)" % [
			dir_path,
			error_string(DirAccess.get_open_error())
		])
		return result

	dir.list_dir_begin()
	var file_name := dir.get_next()

	while file_name != "":
		var full_path := dir_path.path_join(file_name)

		if dir.current_is_dir():
			# Skip hidden directories
			if not file_name.begins_with("."):
				# Recursively search subdirectories
				result.append_array(find_fbx_files(full_path))
		else:
			# Check for FBX files (case-insensitive)
			if file_name.to_lower().ends_with(".fbx"):
				result.append(full_path)

		file_name = dir.get_next()

	dir.list_dir_end()
	return result


## Processes a single FBX file, extracting all meshes.
## Loads the FBX as a PackedScene, finds all MeshInstance3D nodes,
## and saves each as an individual .tscn scene with material overrides.
##
## @param fbx_path Resource path to the FBX file (e.g., "res://PackName/models/Props.fbx").
func process_fbx_file(fbx_path: String) -> void:
	var fbx_name := fbx_path.get_file().get_basename()
	print("  Processing: %s" % fbx_path)

	# Determine relative directory for output (mirror models/ structure in meshes/)
	var models_prefix := current_pack_folder + "/models/"
	var relative_path := fbx_path.trim_prefix(models_prefix)
	var relative_dir := relative_path.get_base_dir()

	# Load the FBX as a PackedScene
	var packed_scene: PackedScene = load(fbx_path)
	if packed_scene == null:
		printerr("    ERROR: Failed to load FBX: %s" % fbx_path)
		errors += 1
		return

	# Instantiate the scene to traverse it
	var scene_instance: Node = packed_scene.instantiate()
	if scene_instance == null:
		printerr("    ERROR: Failed to instantiate scene: %s" % fbx_path)
		errors += 1
		return

	# Find all MeshInstance3D nodes
	var mesh_instances := find_mesh_instances(scene_instance)

	if mesh_instances.is_empty():
		print("    No meshes found in FBX")
		scene_instance.free()
		return

	print("    Found %d mesh(es)" % mesh_instances.size())

	# Extract and save each mesh
	for mesh_instance in mesh_instances:
		extract_and_save_mesh(mesh_instance, relative_dir, fbx_name)

	# Clean up
	scene_instance.free()


## Recursively finds all MeshInstance3D nodes in the scene tree.
## Traverses the entire node hierarchy starting from the given node.
##
## @param node Root node to search from.
## @returns Array[MeshInstance3D] All MeshInstance3D nodes found in the subtree.
func find_mesh_instances(node: Node) -> Array[MeshInstance3D]:
	var result: Array[MeshInstance3D] = []

	if node is MeshInstance3D:
		result.append(node as MeshInstance3D)

	for child in node.get_children():
		result.append_array(find_mesh_instances(child))

	return result


## Extracts mesh from MeshInstance3D, applies materials, and saves as .tscn.
## Creates a new scene with the mesh and material overrides pointing to
## external .tres files. Collision meshes get magenta material for visibility.
##
## @param mesh_instance The MeshInstance3D to extract.
## @param relative_dir Subdirectory path relative to meshes/ for output.
## @param fbx_name Name of source FBX (used for duplicate name resolution).
func extract_and_save_mesh(mesh_instance: MeshInstance3D, relative_dir: String, fbx_name: String) -> void:
	var mesh_name := String(mesh_instance.name)
	var original_mesh := mesh_instance.mesh

	if original_mesh == null:
		print("      Skipping %s (null mesh)" % mesh_name)
		meshes_skipped += 1
		return

	if original_mesh.get_surface_count() == 0:
		print("      Skipping %s (no surfaces)" % mesh_name)
		meshes_skipped += 1
		return

	# Check if this is a collision mesh - apply green wireframe material
	var is_collision := mesh_name.to_lower().contains("collision") or mesh_name.to_lower().ends_with("_col")

	# Create a MeshInstance3D node for the scene
	var scene_mesh_instance := MeshInstance3D.new()
	scene_mesh_instance.mesh = original_mesh  # Use original mesh (no need to duplicate)
	scene_mesh_instance.name = mesh_name

	# Determine base output path using current pack folder
	var meshes_dir := current_pack_folder + "/meshes"
	var output_path: String
	if relative_dir.is_empty():
		output_path = "%s/%s.tscn" % [meshes_dir, mesh_name]
	else:
		output_path = "%s/%s/%s.tscn" % [meshes_dir, relative_dir, mesh_name]

	if is_collision:
		# Apply green wireframe material as override for visibility
		for i in range(original_mesh.get_surface_count()):
			scene_mesh_instance.set_surface_override_material(i, collision_material)

		_ensure_directory_exists(output_path.get_base_dir())

		# Pack and save as scene
		var scene := PackedScene.new()
		var pack_result := scene.pack(scene_mesh_instance)
		if pack_result != OK:
			printerr("      ERROR: Failed to pack collision scene: %s" % mesh_name)
			scene_mesh_instance.free()
			errors += 1
			return

		var save_result := ResourceSaver.save(scene, output_path)
		scene_mesh_instance.free()

		if save_result == OK:
			print("      Saved collision: %s (green wireframe)" % mesh_name)
			meshes_saved += 1
		else:
			printerr("      ERROR: Failed to save collision scene: %s" % mesh_name)
			errors += 1
		return  # Skip normal material lookup

	# Get materials for this mesh (loaded as external resources)
	var material_names := get_material_names_for_mesh(mesh_name)
	var materials_applied := 0

	# Apply materials as overrides (references to external .tres files, not baked in)
	# Materials are in the current pack's materials/ folder
	var materials_dir := current_pack_folder + "/materials"
	for i in range(original_mesh.get_surface_count()):
		if i < material_names.size() and material_names[i] != "":
			var material_path := "%s/%s.tres" % [materials_dir, material_names[i]]

			if not ResourceLoader.exists(material_path):
				print("      Warning: Material not found: %s" % material_path)
				warnings += 1
				continue

			var material: Material = load(material_path)
			if material == null:
				print("      Warning: Failed to load material: %s" % material_path)
				warnings += 1
				continue

			scene_mesh_instance.set_surface_override_material(i, material)
			materials_applied += 1

	# Handle duplicate mesh names by appending FBX source name
	if saved_mesh_names.has(output_path):
		# Mesh with this name already saved from a different FBX
		var unique_name := "%s_%s" % [mesh_name, fbx_name]
		if relative_dir.is_empty():
			output_path = "%s/%s.tscn" % [meshes_dir, unique_name]
		else:
			output_path = "%s/%s/%s.tscn" % [meshes_dir, relative_dir, unique_name]
		print("      Note: Renamed to %s (duplicate name)" % unique_name)
		warnings += 1

	# Ensure output directory exists
	var output_dir := output_path.get_base_dir()
	_ensure_directory_exists(output_dir)

	# Pack and save as scene
	var scene := PackedScene.new()
	var pack_result := scene.pack(scene_mesh_instance)

	if pack_result != OK:
		printerr("      ERROR: Failed to pack scene: %s (error: %s)" % [
			output_path,
			error_string(pack_result)
		])
		scene_mesh_instance.free()
		errors += 1
		return

	var save_result := ResourceSaver.save(scene, output_path)

	# Clean up the temporary node
	scene_mesh_instance.free()

	if save_result != OK:
		printerr("      ERROR: Failed to save scene: %s (error: %s)" % [
			output_path,
			error_string(save_result)
		])
		errors += 1
		return

	# Track saved mesh name
	saved_mesh_names[output_path] = true

	if materials_applied > 0:
		print("      Saved: %s (%d materials)" % [output_path.get_file(), materials_applied])
	else:
		print("      Saved: %s (no materials)" % output_path.get_file())

	meshes_saved += 1


## Looks up material names for a mesh by name.
## Tries exact match first, then strips numeric suffixes added by Godot import
## (like "_001", "_002"). Returns an array of material name strings.
##
## @param mesh_name The mesh name to look up (e.g., "SM_Prop_Crystal_01_001").
## @returns Array[String] Material names for each surface. May contain empty strings
##          for surfaces with no material mapping. Empty array if mesh not found.
func get_material_names_for_mesh(mesh_name: String) -> Array[String]:
	var material_names_result: Array[String] = []
	var lookup_name := mesh_name

	# Try exact match first
	if not mesh_to_materials.has(lookup_name):
		# Try stripping numeric suffixes like "_001", "_002" (Godot import adds these)
		var base_name := _strip_numeric_suffix(mesh_name)
		if base_name != mesh_name and mesh_to_materials.has(base_name):
			lookup_name = base_name
		else:
			print("      Warning: No material mapping for mesh '%s'" % mesh_name)
			warnings += 1
			return material_names_result

	var material_names = mesh_to_materials[lookup_name]

	# Handle both array and single string formats
	if material_names is String:
		material_names = [material_names]

	if not material_names is Array:
		print("      Warning: Invalid material format for mesh '%s'" % lookup_name)
		warnings += 1
		return material_names_result

	# Collect material names
	for material_name in material_names:
		if material_name is String and not material_name.is_empty():
			material_names_result.append(material_name)
		else:
			# Empty material name - append empty string to preserve surface index alignment
			material_names_result.append("")

	return material_names_result


## Strips numeric suffixes like "_001", "_01", "001" from a name.
## Godot's FBX importer adds numeric suffixes to duplicate node names.
## This allows matching meshes even when suffixes are present.
##
## @param name The name to strip suffix from.
## @returns String The name without trailing numeric suffix.
func _strip_numeric_suffix(name: String) -> String:
	var regex := RegEx.new()
	regex.compile("(_?\\d+)$")
	return regex.sub(name, "")


## Ensures a directory exists, creating it recursively if necessary.
## Silently succeeds if directory already exists. Logs warning on failure.
##
## @param dir_path Directory path to create (e.g., "res://PackName/meshes/props").
func _ensure_directory_exists(dir_path: String) -> void:
	if DirAccess.dir_exists_absolute(dir_path):
		return

	var result := DirAccess.make_dir_recursive_absolute(dir_path)
	if result != OK:
		push_warning("Failed to create directory: %s (error: %s)" % [
			dir_path,
			error_string(result)
		])


## Prints a summary of the conversion process.
## Shows counts of saved meshes, skipped meshes, warnings, and errors.
## Provides a final status message based on results.
func print_summary() -> void:
	print("=" .repeat(60))
	print("Conversion Complete")
	print("=" .repeat(60))
	print("  Meshes saved:   %d" % meshes_saved)
	print("  Meshes skipped: %d" % meshes_skipped)
	print("  Warnings:       %d" % warnings)
	print("  Errors:         %d" % errors)
	print("=" .repeat(60))

	if errors > 0:
		print("")
		print("Some meshes failed to save. Check errors above.")
	elif warnings > 0:
		print("")
		print("Conversion completed with warnings. Check logs above.")
	else:
		print("")
		print("All meshes converted successfully!")
