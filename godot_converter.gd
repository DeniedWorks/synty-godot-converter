## Synty Shader Converter - FBX to Scene Converter
##
## Extracts individual meshes from FBX files and saves them as .tscn scene files
## with materials as external references (not baked in).
##
## This script is the Godot-side component of the Synty conversion pipeline.
## It reads mesh-to-material mappings generated by the Python tools and
## applies the correct .tres materials to each mesh surface.
##
## Usage:
##   godot --headless --script res://godot_converter.gd
##
## Prerequisites:
##   - Pack folders containing:
##     - models/ - Directory containing FBX files to convert
##     - materials/ - Directory containing .tres material files
##     - mesh_material_mapping.json - Maps mesh names to material name arrays
##       (generated by material_list.py, one per pack)
##
## Output:
##   - {pack}/meshes/ - Individual .tscn scene files (one per MeshInstance3D found)
##     Each scene has a MeshInstance3D root with material overrides pointing to
##     external .tres files, keeping materials editable and reusable.
##
## Pack Discovery:
##   When pack_name is set in converter_config.json (by the Python CLI), only that
##   specific pack is processed. Otherwise, auto-discovers pack folders by looking
##   for directories containing both models/ and materials/ subdirectories.
##
## Collision Handling:
##   Meshes with "collision" in their name or ending with "_col" are saved
##   with a green wireframe StandardMaterial3D for debugging visibility.
##
## @tutorial(User Guide): docs/user-guide.md
## @tutorial(API Reference): docs/api/godot_converter.md

extends SceneTree

## Maps mesh names to arrays of material names.
## Loaded from res://shaders/mesh_material_mapping.json at startup.
## Keys are mesh names (e.g., "SM_Prop_Crystal_01"), values are
## arrays of material names in surface index order.
## @type Dictionary[String, Array[String]]
var mesh_to_materials: Dictionary = {}

## Tracks mesh names that have been saved to detect duplicates across FBX files.
## Keys are output paths, values are true (just used as a set).
## @type Dictionary[String, bool]
var saved_mesh_names: Dictionary = {}

## Counter for successfully converted and saved meshes.
var meshes_saved: int = 0

## Counter for meshes skipped (null mesh, no surfaces, etc.).
var meshes_skipped: int = 0

## Counter for non-fatal warnings (missing materials, duplicates, etc.).
var warnings: int = 0

## Counter for errors that prevented mesh conversion.
var errors: int = 0

## Magenta material applied to collision meshes for debugging visibility.
## Collision meshes are identified by name containing "collision" or ending with "_col".
var collision_material: StandardMaterial3D = null

## Current pack folder being processed (e.g., "res://PolygonNature_SourceFiles").
## Used for resolving material paths relative to the pack.
var current_pack_folder: String = ""

## Default material name for the current pack (e.g., "PolygonFantasyKingdom_Mat_01_A").
## Detected automatically by scanning for *_Mat_01_A.tres files in the materials folder.
## Used as a final fallback when no material mapping exists for a mesh.
var default_material_name: String = ""

## Configuration options loaded from converter_config.json.
## - pack_name: Target pack folder name. If set, only this pack is processed.
## - keep_meshes_together: If true, all meshes from one FBX are saved in a single scene.
## - mesh_format: Output format - "tscn" (text) or "res" (binary).
## - filter_pattern: Optional filter pattern for FBX filenames.
var config_pack_name: String = ""
var config_keep_meshes_together: bool = false
var config_mesh_format: String = "tscn"
var config_filter_pattern: String = ""
var config_mesh_scale: float = 1.0


## Loads configuration options from converter_config.json.
## This JSON file is generated by the Python CLI and contains options like
## keep_meshes_together, mesh_format, and filter_pattern.
## If the file doesn't exist, defaults are used.
##
## @returns bool True if config was loaded (or defaults used), false on parse error.
func load_converter_config() -> bool:
	const CONFIG_PATH := "res://converter_config.json"

	if not FileAccess.file_exists(CONFIG_PATH):
		print("No converter_config.json found, using defaults")
		return true

	var file := FileAccess.open(CONFIG_PATH, FileAccess.READ)
	if file == null:
		push_warning("Failed to open converter_config.json: %s" % error_string(FileAccess.get_open_error()))
		return true  # Use defaults

	var json_text := file.get_as_text()
	file.close()

	var json := JSON.new()
	var parse_result := json.parse(json_text)

	if parse_result != OK:
		printerr("Failed to parse converter_config.json: %s at line %d" % [
			json.get_error_message(),
			json.get_error_line()
		])
		return false

	var data = json.get_data()
	if not data is Dictionary:
		printerr("Invalid config format: expected Dictionary, got %s" % typeof(data))
		return false

	# Load options with defaults
	var pack_name_val = data.get("pack_name", null)
	config_pack_name = pack_name_val if pack_name_val != null else ""
	config_keep_meshes_together = data.get("keep_meshes_together", false)
	config_mesh_format = data.get("mesh_format", "tscn")
	var filter_val = data.get("filter_pattern", null)
	config_filter_pattern = filter_val if filter_val != null else ""
	if data.has("mesh_scale"):
		var scale_val = float(data["mesh_scale"])
		if scale_val > 0:
			config_mesh_scale = scale_val
		else:
			push_warning("Invalid mesh_scale %s, using 1.0" % scale_val)

	print("Config loaded:")
	if not config_pack_name.is_empty():
		print("  pack_name: %s" % config_pack_name)
	print("  keep_meshes_together: %s" % config_keep_meshes_together)
	print("  mesh_format: %s" % config_mesh_format)
	if not config_filter_pattern.is_empty():
		print("  filter_pattern: %s" % config_filter_pattern)
	if config_mesh_scale != 1.0:
		print("  mesh_scale: %s" % config_mesh_scale)

	return true


## Main entry point. Called when script runs via --script flag.
## Orchestrates the complete FBX-to-TSCN conversion process:
## 1. Loads configuration from converter_config.json
## 2. Loads material mapping from JSON
## 3. Discovers pack folders
## 4. For each pack folder:
##    a. Finds all FBX files in {pack}/models/
##    b. Processes each FBX, extracting meshes and applying materials from {pack}/materials/
##    c. Saves scenes to {pack}/meshes/
## 5. Prints summary and exits with appropriate code
func _init() -> void:
	print("=" .repeat(60))
	print("Synty Shader Converter - FBX to Scene Files")
	print("=" .repeat(60))
	print("")

	# Create wireframe material for collision meshes
	collision_material = StandardMaterial3D.new()
	collision_material.albedo_color = Color(0.0, 1.0, 0.0)  # Green wireframe
	collision_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	collision_material.wireframe = true

	# Load converter configuration
	if not load_converter_config():
		printerr("Failed to parse converter_config.json. Aborting.")
		quit(1)
		return

	# Determine pack folders to process
	var pack_folders: Array[String] = []
	if not config_pack_name.is_empty():
		# Use specific pack from config (set by Python CLI)
		var pack_path := "res://" + config_pack_name
		if DirAccess.dir_exists_absolute(pack_path):
			pack_folders = [pack_path]
			print("Target pack: %s" % pack_path)
		else:
			printerr("Configured pack not found: %s" % pack_path)
			quit(1)
			return
	else:
		# Fallback: discover all pack folders
		pack_folders = discover_pack_folders()
		if pack_folders.is_empty():
			print("No pack folders found (directories with models/ and materials/ subdirs)")
			quit(0)
			return
		print("Found %d pack folder(s): %s" % [pack_folders.size(), ", ".join(pack_folders)])

	print("")

	# Process each pack folder
	for pack_folder in pack_folders:
		process_pack_folder(pack_folder)

	print("")
	print_summary()

	# Exit with error code only if no meshes were saved at all
	# Warnings (missing materials, etc.) are expected and shouldn't cause failure
	var exit_code := 0 if meshes_saved > 0 else 1
	quit(exit_code)


## Discovers pack folders at the project root.
## Pack folders are identified by having both models/ and materials/ subdirectories.
## Hidden directories (starting with .) and special directories (.godot, shaders, meshes)
## are skipped.
##
## @returns Array[String] Array of pack folder resource paths (e.g., "res://PackName").
func discover_pack_folders() -> Array[String]:
	var result: Array[String] = []
	var root_dir := DirAccess.open("res://")

	if root_dir == null:
		printerr("Cannot open project root directory")
		return result

	root_dir.list_dir_begin()
	var dir_name := root_dir.get_next()

	while dir_name != "":
		if root_dir.current_is_dir():
			# Skip hidden and special directories
			if not dir_name.begins_with(".") and dir_name != "shaders" and dir_name != "meshes":
				var pack_path := "res://" + dir_name
				var models_path := pack_path + "/models"
				var materials_path := pack_path + "/materials"

				# Check if this is a valid pack folder (has both models and materials)
				if DirAccess.dir_exists_absolute(models_path) and DirAccess.dir_exists_absolute(materials_path):
					result.append(pack_path)

		dir_name = root_dir.get_next()

	root_dir.list_dir_end()
	return result


## Processes a single pack folder, converting all FBX files within it.
##
## @param pack_folder Resource path to the pack folder (e.g., "res://PolygonNature_SourceFiles").
func process_pack_folder(pack_folder: String) -> void:
	print("Processing pack: %s" % pack_folder)
	current_pack_folder = pack_folder

	# Load material mapping for this pack (each pack has its own mapping file)
	if not load_material_mapping(pack_folder):
		printerr("  Failed to load material mapping for pack. Skipping.")
		return

	# Detect default material for this pack
	var materials_path := pack_folder + "/materials"
	default_material_name = _detect_default_material(materials_path)
	if not default_material_name.is_empty():
		print("  Default material: %s" % default_material_name)
	else:
		print("  No default material found (no *_Mat_01_A.tres files)")

	var models_path := pack_folder + "/models"
	var meshes_output := pack_folder + "/meshes"

	# Ensure output directory exists
	_ensure_directory_exists(meshes_output)

	# Find all FBX files in the pack's models directory
	var fbx_files := find_fbx_files(models_path)

	if fbx_files.is_empty():
		print("  No FBX files found in %s" % models_path)
		return

	var total_fbx := fbx_files.size()
	print("  Found %d FBX file(s) to process" % total_fbx)

	for i in range(fbx_files.size()):
		var fbx_path := fbx_files[i]
		print("[%d/%d] Processing: %s" % [i + 1, total_fbx, fbx_path.get_file()])
		process_fbx_file(fbx_path)


## Loads the mesh-to-material mapping from JSON file.
## The JSON file maps mesh names to arrays of material names.
## This mapping is generated by the Python material_list.py tool.
## Each pack has its own mapping file at {pack}/mesh_material_mapping.json.
##
## @param pack_folder Resource path to the pack folder (e.g., "res://POLYGON_Nature").
## @returns bool True if loading succeeded, false otherwise.
func load_material_mapping(pack_folder: String) -> bool:
	var mapping_path := pack_folder + "/mesh_material_mapping.json"

	if not FileAccess.file_exists(mapping_path):
		printerr("Material mapping file not found: %s" % mapping_path)
		return false

	var file := FileAccess.open(mapping_path, FileAccess.READ)
	if file == null:
		printerr("Failed to open mapping file: %s (error: %s)" % [
			mapping_path,
			error_string(FileAccess.get_open_error())
		])
		return false

	var json_text := file.get_as_text()
	file.close()

	var json := JSON.new()
	var parse_result := json.parse(json_text)

	if parse_result != OK:
		printerr("Failed to parse JSON: %s at line %d" % [
			json.get_error_message(),
			json.get_error_line()
		])
		return false

	var data = json.get_data()
	if not data is Dictionary:
		printerr("Invalid mapping format: expected Dictionary, got %s" % typeof(data))
		return false

	mesh_to_materials = data
	print("  Loaded material mapping with %d mesh entries" % mesh_to_materials.size())

	return true


## Recursively finds all FBX files in the given directory.
## Searches subdirectories and returns paths to all .fbx files found.
## Hidden directories (starting with .) are skipped.
## If config_filter_pattern is set, only files containing the pattern are returned.
##
## @param dir_path Resource path to search (e.g., "res://PackName/models").
## @returns Array[String] Array of FBX file paths found.
func find_fbx_files(dir_path: String) -> Array[String]:
	var result: Array[String] = []
	var dir := DirAccess.open(dir_path)

	if dir == null:
		push_warning("Cannot open directory: %s (error: %s)" % [
			dir_path,
			error_string(DirAccess.get_open_error())
		])
		return result

	dir.list_dir_begin()
	var file_name := dir.get_next()

	while file_name != "":
		var full_path := dir_path.path_join(file_name)

		if dir.current_is_dir():
			# Skip hidden directories
			if not file_name.begins_with("."):
				# Recursively search subdirectories
				result.append_array(find_fbx_files(full_path))
		else:
			# Check for FBX files (case-insensitive)
			if file_name.to_lower().ends_with(".fbx"):
				# Apply filter pattern if set
				if config_filter_pattern.is_empty():
					result.append(full_path)
				else:
					# Case-insensitive pattern matching
					var base_name := file_name.get_basename()
					if base_name.to_lower().contains(config_filter_pattern.to_lower()):
						result.append(full_path)

		file_name = dir.get_next()

	dir.list_dir_end()
	return result


## Processes a single FBX file, extracting meshes based on config.
## Loads the FBX as a PackedScene, finds all MeshInstance3D nodes,
## and either saves each as individual scene files (default) or keeps
## them together in a single scene (when keep_meshes_together is true).
##
## @param fbx_path Resource path to the FBX file (e.g., "res://PackName/models/Props.fbx").
func process_fbx_file(fbx_path: String) -> void:
	var fbx_name := fbx_path.get_file().get_basename()
	print("  Processing: %s" % fbx_path)

	# Determine relative directory for output (mirror models/ structure in meshes/)
	var models_prefix := current_pack_folder + "/models/"
	var relative_path := fbx_path.trim_prefix(models_prefix)
	var relative_dir := relative_path.get_base_dir()

	# Load the FBX as a PackedScene
	var packed_scene: PackedScene = load(fbx_path)
	if packed_scene == null:
		printerr("    ERROR: Failed to load FBX: %s" % fbx_path)
		errors += 1
		return

	# Instantiate the scene to traverse it
	var scene_instance: Node = packed_scene.instantiate()
	if scene_instance == null:
		printerr("    ERROR: Failed to instantiate scene: %s" % fbx_path)
		errors += 1
		return

	# Find all MeshInstance3D nodes
	var mesh_instances := find_mesh_instances(scene_instance)

	if mesh_instances.is_empty():
		print("    No meshes found in FBX")
		scene_instance.free()
		return

	print("    Found %d mesh(es)" % mesh_instances.size())

	if config_keep_meshes_together:
		# Keep all meshes together in a single scene file
		save_fbx_as_single_scene(scene_instance, mesh_instances, relative_dir, fbx_name)
	else:
		# Extract and save each mesh separately (default behavior)
		for mesh_instance in mesh_instances:
			extract_and_save_mesh(mesh_instance, relative_dir, fbx_name)

	# Clean up
	scene_instance.free()


## Saves all meshes from an FBX as a single scene file.
## Applies materials to all mesh instances and saves the entire scene tree.
## Used when --keep-meshes-together is enabled.
##
## @param scene_root The root node of the FBX scene.
## @param mesh_instances Array of all MeshInstance3D nodes to process.
## @param relative_dir Subdirectory path relative to meshes/ for output.
## @param fbx_name Name of the FBX file (used as scene name).
func save_fbx_as_single_scene(scene_root: Node, mesh_instances: Array[MeshInstance3D], relative_dir: String, fbx_name: String) -> void:
	var materials_dir := current_pack_folder + "/materials"
	var materials_applied := 0

	# Apply materials to each mesh instance
	for mesh_instance in mesh_instances:
		var mesh_name := String(mesh_instance.name)
		var original_mesh := mesh_instance.mesh

		if original_mesh == null or original_mesh.get_surface_count() == 0:
			continue

		# Apply mesh scale if configured
		if config_mesh_scale != 1.0:
			original_mesh = scale_mesh(original_mesh, config_mesh_scale)
			mesh_instance.mesh = original_mesh

		# Check if this is a collision mesh
		var is_collision := mesh_name.to_lower().contains("collision") or mesh_name.to_lower().ends_with("_col")

		if is_collision:
			# Apply green wireframe material
			for i in range(original_mesh.get_surface_count()):
				mesh_instance.set_surface_override_material(i, collision_material)
			continue

		# Get materials for this mesh
		var material_names := get_material_names_for_mesh(mesh_name)

		# Apply materials as overrides
		for i in range(original_mesh.get_surface_count()):
			if i < material_names.size() and material_names[i] != "":
				var mat_name := material_names[i]
				var material_path := find_material_path(mat_name, materials_dir)

				if material_path.is_empty():
					print("      Warning: Material not found: %s" % mat_name)
					warnings += 1
					continue

				var material: Material = load(material_path)
				if material == null:
					print("      Warning: Failed to load material: %s" % material_path)
					warnings += 1
					continue

				mesh_instance.set_surface_override_material(i, material)
				materials_applied += 1

	# Determine output path
	var meshes_dir := current_pack_folder + "/meshes"
	var output_path: String
	var file_ext := "." + config_mesh_format

	if relative_dir.is_empty():
		output_path = "%s/%s%s" % [meshes_dir, fbx_name, file_ext]
	else:
		output_path = "%s/%s/%s%s" % [meshes_dir, relative_dir, fbx_name, file_ext]

	# Ensure output directory exists
	_ensure_directory_exists(output_path.get_base_dir())

	var save_result: Error

	if config_mesh_format == "res":
		# For .res format: merge all meshes into a single ArrayMesh
		var combined_mesh := ArrayMesh.new()

		for mesh_instance in mesh_instances:
			var original_mesh := mesh_instance.mesh
			if original_mesh == null:
				continue

			# Add each surface from this mesh to the combined mesh
			for surf_idx in range(original_mesh.get_surface_count()):
				var arrays := original_mesh.surface_get_arrays(surf_idx)
				var blend_shapes: Array[Array] = []
				for bs_idx in range(original_mesh.get_blend_shape_count()):
					blend_shapes.append(original_mesh.surface_get_blend_shape_arrays(surf_idx)[bs_idx])

				var primitive_type: Mesh.PrimitiveType = original_mesh.surface_get_primitive_type(surf_idx)
				combined_mesh.add_surface_from_arrays(primitive_type, arrays, blend_shapes)

				# Get material (either override or from mesh)
				var material: Material = mesh_instance.get_surface_override_material(surf_idx)
				if material == null:
					material = original_mesh.surface_get_material(surf_idx)
				if material != null:
					combined_mesh.surface_set_material(combined_mesh.get_surface_count() - 1, material)

		save_result = ResourceSaver.save(combined_mesh, output_path)
	else:
		# For .tscn format: save as PackedScene with multiple mesh nodes
		# Create a new root node (Node3D) with proper ownership for all children
		var new_root := Node3D.new()
		new_root.name = fbx_name

		# Duplicate children and add to new root with proper ownership
		for child in scene_root.get_children():
			var duplicated := child.duplicate()
			new_root.add_child(duplicated)
			_set_owner_recursive(duplicated, new_root)

		# Pack and save
		var scene := PackedScene.new()
		var pack_result := scene.pack(new_root)

		if pack_result != OK:
			printerr("      ERROR: Failed to pack scene: %s (error: %s)" % [
				output_path,
				error_string(pack_result)
			])
			new_root.free()
			errors += 1
			return

		save_result = ResourceSaver.save(scene, output_path)
		new_root.free()

	if save_result != OK:
		printerr("      ERROR: Failed to save: %s (error: %s)" % [
			output_path,
			error_string(save_result)
		])
		errors += 1
		return

	print("      Saved combined: %s (%d meshes, %d materials)" % [
		output_path.get_file(), mesh_instances.size(), materials_applied
	])
	meshes_saved += 1


## Recursively sets the owner of a node and all its children.
## Required for PackedScene.pack() to include all nodes in the saved scene.
##
## @param node The node to set ownership on.
## @param owner The owner node (typically the scene root).
func _set_owner_recursive(node: Node, owner: Node) -> void:
	node.owner = owner
	for child in node.get_children():
		_set_owner_recursive(child, owner)


## Recursively finds all MeshInstance3D nodes in the scene tree.
## Traverses the entire node hierarchy starting from the given node.
##
## @param node Root node to search from.
## @returns Array[MeshInstance3D] All MeshInstance3D nodes found in the subtree.
func find_mesh_instances(node: Node) -> Array[MeshInstance3D]:
	var result: Array[MeshInstance3D] = []

	if node is MeshInstance3D:
		result.append(node as MeshInstance3D)

	for child in node.get_children():
		result.append_array(find_mesh_instances(child))

	return result


## Extracts mesh from MeshInstance3D, applies materials, and saves as .tscn.
## Creates a new scene with the mesh and material overrides pointing to
## external .tres files. Collision meshes get magenta material for visibility.
##
## @param mesh_instance The MeshInstance3D to extract.
## @param relative_dir Subdirectory path relative to meshes/ for output.
## @param fbx_name Name of source FBX (used for duplicate name resolution).
func extract_and_save_mesh(mesh_instance: MeshInstance3D, relative_dir: String, fbx_name: String) -> void:
	var mesh_name := String(mesh_instance.name)
	var original_mesh := mesh_instance.mesh

	if original_mesh == null:
		print("      Skipping %s (null mesh)" % mesh_name)
		meshes_skipped += 1
		return

	if original_mesh.get_surface_count() == 0:
		print("      Skipping %s (no surfaces)" % mesh_name)
		meshes_skipped += 1
		return

	# Apply mesh scale if configured
	if config_mesh_scale != 1.0:
		original_mesh = scale_mesh(original_mesh, config_mesh_scale)

	# Check if this is a collision mesh - apply green wireframe material
	var is_collision := mesh_name.to_lower().contains("collision") or mesh_name.to_lower().ends_with("_col")

	# Create a MeshInstance3D node for the scene
	var scene_mesh_instance := MeshInstance3D.new()
	scene_mesh_instance.mesh = original_mesh  # Use original mesh (or scaled copy)
	scene_mesh_instance.name = mesh_name

	# Determine base output path using current pack folder
	var meshes_dir := current_pack_folder + "/meshes"
	var file_ext := "." + config_mesh_format
	var output_path: String
	if relative_dir.is_empty():
		output_path = "%s/%s%s" % [meshes_dir, mesh_name, file_ext]
	else:
		output_path = "%s/%s/%s%s" % [meshes_dir, relative_dir, mesh_name, file_ext]

	if is_collision:
		# Apply green wireframe material as override for visibility
		for i in range(original_mesh.get_surface_count()):
			scene_mesh_instance.set_surface_override_material(i, collision_material)

		_ensure_directory_exists(output_path.get_base_dir())

		var save_result: Error

		if config_mesh_format == "res":
			# For .res format: save just the ArrayMesh with collision material baked in
			var mesh_to_save: ArrayMesh = original_mesh.duplicate() as ArrayMesh
			for i in range(mesh_to_save.get_surface_count()):
				mesh_to_save.surface_set_material(i, collision_material)
			save_result = ResourceSaver.save(mesh_to_save, output_path)
			scene_mesh_instance.free()
		else:
			# For .tscn format: save as PackedScene
			var scene := PackedScene.new()
			var pack_result := scene.pack(scene_mesh_instance)
			if pack_result != OK:
				printerr("      ERROR: Failed to pack collision scene: %s" % mesh_name)
				scene_mesh_instance.free()
				errors += 1
				return
			save_result = ResourceSaver.save(scene, output_path)
			scene_mesh_instance.free()

		if save_result == OK:
			print("      Saved collision: %s (green wireframe)" % mesh_name)
			meshes_saved += 1
		else:
			printerr("      ERROR: Failed to save collision: %s" % mesh_name)
			errors += 1
		return  # Skip normal material lookup

	# Get materials for this mesh (loaded as external resources)
	var material_names := get_material_names_for_mesh(mesh_name)
	var materials_applied := 0

	# Apply materials as overrides (references to external .tres files, not baked in)
	# Materials are in the current pack's materials/ folder
	var materials_dir := current_pack_folder + "/materials"
	for i in range(original_mesh.get_surface_count()):
		if i < material_names.size() and material_names[i] != "":
			var mat_name := material_names[i]
			# Use fallback logic to find material (handles prefix mismatches)
			var material_path := find_material_path(mat_name, materials_dir)

			if material_path.is_empty():
				print("      Warning: Material not found: %s (tried fallbacks)" % mat_name)
				warnings += 1
				continue

			var material: Material = load(material_path)
			if material == null:
				print("      Warning: Failed to load material: %s" % material_path)
				warnings += 1
				continue

			scene_mesh_instance.set_surface_override_material(i, material)
			materials_applied += 1

	# Handle duplicate mesh names by appending FBX source name
	if saved_mesh_names.has(output_path):
		# Mesh with this name already saved from a different FBX
		var unique_name := "%s_%s" % [mesh_name, fbx_name]
		if relative_dir.is_empty():
			output_path = "%s/%s%s" % [meshes_dir, unique_name, file_ext]
		else:
			output_path = "%s/%s/%s%s" % [meshes_dir, relative_dir, unique_name, file_ext]
		print("      Note: Renamed to %s (duplicate name)" % unique_name)
		warnings += 1

	# Ensure output directory exists
	var output_dir := output_path.get_base_dir()
	_ensure_directory_exists(output_dir)

	var save_result: Error

	if config_mesh_format == "res":
		# For .res format: save just the ArrayMesh with materials baked into surfaces
		var mesh_to_save: ArrayMesh = original_mesh.duplicate() as ArrayMesh

		# Apply materials directly to the mesh surfaces
		for i in range(mesh_to_save.get_surface_count()):
			var override_mat := scene_mesh_instance.get_surface_override_material(i)
			if override_mat != null:
				mesh_to_save.surface_set_material(i, override_mat)

		save_result = ResourceSaver.save(mesh_to_save, output_path)
		scene_mesh_instance.free()
	else:
		# For .tscn format: save as PackedScene with MeshInstance3D node
		var scene := PackedScene.new()
		var pack_result := scene.pack(scene_mesh_instance)

		if pack_result != OK:
			printerr("      ERROR: Failed to pack scene: %s (error: %s)" % [
				output_path,
				error_string(pack_result)
			])
			scene_mesh_instance.free()
			errors += 1
			return

		save_result = ResourceSaver.save(scene, output_path)
		scene_mesh_instance.free()

	if save_result != OK:
		printerr("      ERROR: Failed to save: %s (error: %s)" % [
			output_path,
			error_string(save_result)
		])
		errors += 1
		return

	# Track saved mesh name
	saved_mesh_names[output_path] = true

	if materials_applied > 0:
		print("      Saved: %s (%d materials)" % [output_path.get_file(), materials_applied])
	else:
		print("      Saved: %s (no materials)" % output_path.get_file())

	meshes_saved += 1


## Looks up material names for a mesh by name.
## Uses comprehensive fallback system:
## 1. Try exact match
## 2. Generate all name variations (prefix swaps, suffix removal, combinations)
## 3. Try fuzzy matching (Levenshtein distance <= 2) as last resort
##
## @param mesh_name The mesh name to look up (e.g., "SM_Prop_Crystal_01_001").
## @returns Array[String] Material names for each surface. May contain empty strings
##          for surfaces with no material mapping. Empty array if mesh not found.
func get_material_names_for_mesh(mesh_name: String) -> Array[String]:
	var material_names_result: Array[String] = []
	var lookup_name := mesh_name

	# Try exact match first
	if not mesh_to_materials.has(lookup_name):
		# Generate all possible name variations and try each
		var variations := _generate_name_variations(mesh_name)
		var found := false

		for variation in variations:
			if mesh_to_materials.has(variation):
				print("      Fallback: '%s' -> '%s'" % [mesh_name, variation])
				lookup_name = variation
				found = true
				break

		if not found:
			# Last resort: fuzzy matching (Levenshtein distance <= 2)
			var fuzzy_match := _try_fuzzy_match(mesh_name, 2)
			if not fuzzy_match.is_empty():
				print("      Fuzzy match: '%s' -> '%s'" % [mesh_name, fuzzy_match])
				lookup_name = fuzzy_match
				found = true

		if not found:
			# Final fallback: use default material if available
			if not default_material_name.is_empty():
				print("      Using default material for mesh '%s': %s" % [mesh_name, default_material_name])
				material_names_result.append(default_material_name)
				return material_names_result
			else:
				print("      Warning: No material mapping for mesh '%s'" % mesh_name)
				warnings += 1
				return material_names_result

	var material_names = mesh_to_materials[lookup_name]

	# Handle both array and single string formats
	if material_names is String:
		material_names = [material_names]

	if not material_names is Array:
		print("      Warning: Invalid material format for mesh '%s'" % lookup_name)
		warnings += 1
		return material_names_result

	# Collect material names
	for material_name in material_names:
		if material_name is String and not material_name.is_empty():
			material_names_result.append(material_name)
		else:
			# Empty material name - append empty string to preserve surface index alignment
			material_names_result.append("")

	return material_names_result


## Generates all possible name variations for fallback matching.
## Combines multiple transformations to handle various naming mismatches.
##
## Transformations applied:
## - Prefix swaps: SK_ <-> SM_
## - Suffix removal: _Static, _Preset, component suffixes
## - Godot numeric suffix stripping: _001, _002, etc.
##
## @param mesh_name The original mesh name.
## @returns Array[String] All possible name variations (excluding original).
func _generate_name_variations(mesh_name: String) -> Array[String]:
	var variations: Array[String] = []
	var base_names: Array[String] = [mesh_name]

	# Step 1: Generate base name variants (strip Godot-added numeric suffixes)
	var stripped := _strip_numeric_suffix(mesh_name)
	if stripped != mesh_name:
		base_names.append(stripped)

	# Step 2: For each base name, apply all transformations
	for base in base_names:
		# Prefix transformations
		var prefix_variants := _get_prefix_variants(base)

		# Suffix transformations
		var suffix_variants := _get_suffix_variants(base)

		# Add prefix variants
		for pv in prefix_variants:
			if pv != mesh_name and not variations.has(pv):
				variations.append(pv)

		# Add suffix variants
		for sv in suffix_variants:
			if sv != mesh_name and not variations.has(sv):
				variations.append(sv)

		# Combine: apply prefix transforms to suffix variants
		for sv in suffix_variants:
			var combined := _get_prefix_variants(sv)
			for cv in combined:
				if cv != mesh_name and not variations.has(cv):
					variations.append(cv)

		# Combine: apply suffix transforms to prefix variants
		for pv in prefix_variants:
			var combined := _get_suffix_variants(pv)
			for cv in combined:
				if cv != mesh_name and not variations.has(cv):
					variations.append(cv)

	return variations


## Gets prefix variants for a name (SK_ <-> SM_ swaps).
func _get_prefix_variants(name: String) -> Array[String]:
	var variants: Array[String] = []

	# SK_ to SM_ (skeletal to static mesh)
	if name.begins_with("SK_"):
		variants.append("SM_" + name.substr(3))

	# SM_ to SK_ (static to skeletal mesh)
	if name.begins_with("SM_"):
		variants.append("SK_" + name.substr(3))

	return variants


## Gets suffix variants for a name (remove common suffixes).
func _get_suffix_variants(name: String) -> Array[String]:
	var variants: Array[String] = []

	# Suffixes to try removing
	var suffixes_to_remove: Array[String] = [
		"_Static", "_Preset",
		"_Cork", "_Liquid", "_Handle",
		"_Door_1", "_Door_2", "_Door_01", "_Door_02",
		"_Drawer_01", "_Drawer_02", "_Drawer_03",
		"_Chains_01", "_Chains_02",
		"_Arrow_01", "_Arrow_02", "_Arrow_03",
		"_LOD0", "_LOD1", "_LOD2", "_LOD3"
	]

	for suffix in suffixes_to_remove:
		if name.ends_with(suffix):
			var without_suffix := name.substr(0, name.length() - suffix.length())
			if not variants.has(without_suffix):
				variants.append(without_suffix)

	# Also try ADDING _Static suffix (FBX might not have it but MaterialList does)
	if not name.ends_with("_Static"):
		variants.append(name + "_Static")

	return variants


## Tries fuzzy matching using Levenshtein distance.
## Finds the closest match in the material mapping within the given distance threshold.
##
## @param mesh_name The mesh name to find a fuzzy match for.
## @param max_distance Maximum Levenshtein distance to consider a match.
## @returns String The best matching name, or empty string if no match within threshold.
func _try_fuzzy_match(mesh_name: String, max_distance: int) -> String:
	var best_match := ""
	var best_distance := max_distance + 1

	# Compare against all keys in the mapping
	for key in mesh_to_materials.keys():
		# Quick length check to skip obviously different names
		if abs(key.length() - mesh_name.length()) > max_distance:
			continue

		var distance := _levenshtein_distance(mesh_name, key)
		if distance <= max_distance and distance < best_distance:
			best_distance = distance
			best_match = key

			# Early exit if we find an exact or near-exact match
			if distance <= 1:
				break

	return best_match


## Calculates Levenshtein distance between two strings.
## This measures the minimum number of single-character edits (insertions,
## deletions, or substitutions) required to change one string into the other.
##
## @param s1 First string.
## @param s2 Second string.
## @returns int The Levenshtein distance.
func _levenshtein_distance(s1: String, s2: String) -> int:
	var len1 := s1.length()
	var len2 := s2.length()

	# Quick checks
	if len1 == 0:
		return len2
	if len2 == 0:
		return len1
	if s1 == s2:
		return 0

	# Create distance matrix (using two rows for memory efficiency)
	var prev_row: Array[int] = []
	var curr_row: Array[int] = []

	# Initialize first row
	for j in range(len2 + 1):
		prev_row.append(j)
		curr_row.append(0)

	# Fill in the rest of the matrix
	for i in range(1, len1 + 1):
		curr_row[0] = i

		for j in range(1, len2 + 1):
			var cost := 0 if s1[i - 1] == s2[j - 1] else 1

			curr_row[j] = mini(
				mini(
					prev_row[j] + 1,      # Deletion
					curr_row[j - 1] + 1   # Insertion
				),
				prev_row[j - 1] + cost    # Substitution
			)

		# Swap rows
		var temp := prev_row
		prev_row = curr_row
		curr_row = temp

	return prev_row[len2]


## Strips numeric suffixes like "_001", "_01", "001" from a name.
## Godot's FBX importer adds numeric suffixes to duplicate node names.
## This allows matching meshes even when suffixes are present.
##
## @param name The name to strip suffix from.
## @returns String The name without trailing numeric suffix.
func _strip_numeric_suffix(name: String) -> String:
	var regex := RegEx.new()
	regex.compile("(_?\\d+)$")
	return regex.sub(name, "")


## Detects the default material for a pack by scanning for *_Mat_01_A.tres files.
## The pattern is typically Polygon{PackName}_Mat_01_A, which is the base material
## used by most meshes in Synty packs.
##
## @param materials_dir Path to the materials directory to scan.
## @returns String The default material name (without .tres extension), or empty string if not found.
func _detect_default_material(materials_dir: String) -> String:
	var dir := DirAccess.open(materials_dir)
	if dir == null:
		return ""

	dir.list_dir_begin()
	var file_name := dir.get_next()

	while file_name != "":
		if not dir.current_is_dir():
			# Check for *_Mat_01_A.tres pattern (case-insensitive check)
			if file_name.to_lower().ends_with(".tres"):
				var base_name := file_name.get_basename()
				if base_name.ends_with("_Mat_01_A"):
					dir.list_dir_end()
					return base_name

		file_name = dir.get_next()

	dir.list_dir_end()
	return ""


## Scales all vertices in a mesh by a given factor.
## Creates a new ArrayMesh with scaled vertices while preserving all other
## surface data (normals, UVs, materials, etc.).
##
## @param mesh The original ArrayMesh to scale.
## @param scale_factor The scale multiplier for vertex positions.
## @returns ArrayMesh A new mesh with scaled vertices.
func scale_mesh(mesh: ArrayMesh, scale_factor: float) -> ArrayMesh:
	var scaled := ArrayMesh.new()
	for surface_idx in mesh.get_surface_count():
		var arrays := mesh.surface_get_arrays(surface_idx)
		var verts: PackedVector3Array = arrays[Mesh.ARRAY_VERTEX]
		for i in verts.size():
			verts[i] *= scale_factor
		arrays[Mesh.ARRAY_VERTEX] = verts
		var mat := mesh.surface_get_material(surface_idx)
		var primitive_type: Mesh.PrimitiveType = mesh.surface_get_primitive_type(surface_idx)
		scaled.add_surface_from_arrays(primitive_type, arrays)
		scaled.surface_set_material(surface_idx, mat)
	return scaled


## Tries to find a material file with fallback for naming mismatches.
## MaterialList.txt often references materials with full prefixes like
## "PolygonFantasyKingdom_Mat_Castle_Wall_01" but the generated .tres files
## are named with just the suffix part like "Castle_Wall_01.tres".
##
## Fallback order:
## 1. Exact name match
## 2. Strip Polygon*_Mat_ prefix (e.g., PolygonFantasyKingdom_Mat_Glass -> Glass)
## 3. Strip Polygon*_ prefix (e.g., PolygonNature_Tree -> Tree)
## 4. Try with _01 suffix if not already present
##
## @param mat_name The material name from the mapping (may have full prefix).
## @param materials_dir Path to the materials directory to search in.
## @returns String Full path to the material file if found, empty string otherwise.
func find_material_path(mat_name: String, materials_dir: String) -> String:
	var base_path := materials_dir.path_join(mat_name + ".tres")

	# 1. Try exact name
	# NOTE: Use ResourceLoader.exists() instead of FileAccess.file_exists() for res:// paths.
	# FileAccess.file_exists() has known issues with resource paths, especially:
	# - During headless execution in _init()
	# - With .remap files created by Godot's import system
	if ResourceLoader.exists(base_path):
		return base_path

	# 2. Strip Polygon*_Mat_ or Polygon*_ prefix
	var stripped := mat_name
	if stripped.begins_with("Polygon"):
		# Try to find _Mat_ first (e.g., PolygonFantasyKingdom_Mat_Glass -> Glass)
		var mat_idx := stripped.find("_Mat_")
		if mat_idx > 0:
			stripped = stripped.substr(mat_idx + 5)  # len("_Mat_") = 5
		else:
			# Try just first underscore after Polygon prefix (e.g., PolygonNature_Tree -> Tree)
			var first_underscore := stripped.find("_")
			if first_underscore > 0:
				stripped = stripped.substr(first_underscore + 1)

	# 3. Try stripped name
	var stripped_path := materials_dir.path_join(stripped + ".tres")
	if ResourceLoader.exists(stripped_path):
		return stripped_path

	# 4. Try with _01 suffix if not already present
	if not stripped.ends_with("_01"):
		var with_suffix_path := materials_dir.path_join(stripped + "_01.tres")
		if ResourceLoader.exists(with_suffix_path):
			return with_suffix_path

	# 5. Try keyword matching (handles cases like Crystal_Mat_01 -> Synty_Crystal)
	var keywords := _extract_material_keywords(mat_name)
	if keywords.size() > 0:
		var best_match := _find_best_keyword_match(materials_dir, keywords)
		if best_match != "":
			return best_match

	# 6. Not found
	return ""


## Extracts keywords from a material name for fuzzy matching.
## Splits on underscores and camelCase, returns weighted keywords.
## Words >3 chars are meaningful (crystal, water, leaf) and get weight 10.
## Words <=3 chars are often generic (mat, 01, a) and get weight 1.
## Example: "Crystal_Mat_01" -> [["crystal", 10], ["mat", 1], ["01", 1]]
## Example: "WaterScrolling_01" -> [["water", 10], ["scrolling", 10], ["01", 1]]
##
## @param name The material name to extract keywords from.
## @returns Array of [keyword, weight] pairs.
func _extract_material_keywords(name: String) -> Array:
	# First replace underscores with spaces
	var spaced := name.replace("_", " ")

	# Split camelCase: insert space before each uppercase letter
	var with_camel_split := ""
	for i in range(spaced.length()):
		var c := spaced[i]
		# Insert space before uppercase if not at start and previous wasn't space
		if i > 0 and c >= "A" and c <= "Z" and spaced[i - 1] != " ":
			with_camel_split += " "
		with_camel_split += c

	var parts := with_camel_split.split(" ", false)
	var keywords: Array = []
	for part in parts:
		var lower := part.to_lower()
		if lower.length() > 0:
			# Words >3 chars are meaningful, <=3 chars are often generic
			var weight := 10 if lower.length() > 3 else 1
			keywords.append([lower, weight])
	return keywords


## Finds the best matching material file based on weighted keyword overlap.
## Scans all .tres files in the directory and scores them by keyword matches.
## Meaningful keywords (crystal, water) score higher than generic ones (mat, 01).
##
## @param materials_dir Path to the materials directory.
## @param keywords Array of [keyword, weight] pairs to match against.
## @returns String Path to best matching material, or empty string if none found.
func _find_best_keyword_match(materials_dir: String, keywords: Array) -> String:
	var dir := DirAccess.open(materials_dir)
	if not dir:
		return ""

	var best_match := ""
	var best_score := 0

	dir.list_dir_begin()
	var file_name := dir.get_next()
	while file_name != "":
		if file_name.ends_with(".tres"):
			var score := _count_keyword_matches(file_name, keywords)
			if score > best_score:
				best_score = score
				best_match = file_name
		file_name = dir.get_next()
	dir.list_dir_end()

	# Require meaningful match (at least one non-generic keyword, i.e., score >= 10)
	if best_score >= 10 and best_match != "":
		return materials_dir.path_join(best_match)
	return ""


## Counts weighted keyword matches in a filename.
## Returns sum of weights for all matching keywords.
##
## @param filename The filename to check (e.g., "Synty_Crystal.tres").
## @param keywords Array of [keyword, weight] pairs.
## @returns int Weighted score of matching keywords.
func _count_keyword_matches(filename: String, keywords: Array) -> int:
	var score := 0
	var lower_name := filename.to_lower()
	for kw_pair in keywords:
		var keyword: String = kw_pair[0]
		var weight: int = kw_pair[1]
		if keyword in lower_name:
			score += weight
	return score


## Ensures a directory exists, creating it recursively if necessary.
## Silently succeeds if directory already exists. Logs warning on failure.
##
## @param dir_path Directory path to create (e.g., "res://PackName/meshes/props").
func _ensure_directory_exists(dir_path: String) -> void:
	if DirAccess.dir_exists_absolute(dir_path):
		return

	var result := DirAccess.make_dir_recursive_absolute(dir_path)
	if result != OK:
		push_warning("Failed to create directory: %s (error: %s)" % [
			dir_path,
			error_string(result)
		])


## Prints a summary of the conversion process.
## Shows counts of saved meshes, skipped meshes, warnings, and errors.
## Provides a final status message based on results.
func print_summary() -> void:
	print("=" .repeat(60))
	print("Conversion Complete")
	print("=" .repeat(60))
	print("  Output format:  .%s" % config_mesh_format)
	if config_keep_meshes_together:
		print("  Mode:           Combined scenes (one per FBX)")
	else:
		print("  Mode:           Individual meshes")
	print("  Meshes saved:   %d" % meshes_saved)
	print("  Meshes skipped: %d" % meshes_skipped)
	print("  Warnings:       %d" % warnings)
	print("  Errors:         %d" % errors)
	print("=" .repeat(60))

	if errors > 0:
		print("")
		print("Some meshes failed to save. Check errors above.")
	elif warnings > 0:
		print("")
		print("Conversion completed with warnings. Check logs above.")
	else:
		print("")
		print("All meshes converted successfully!")
