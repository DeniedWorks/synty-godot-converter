## Synty Shader Converter - FBX to Scene Converter
##
## Extracts individual meshes from FBX files and saves them as .tscn scene files
## with materials as external references (not baked in).
##
## This script is the Godot-side component of the Synty conversion pipeline.
## It reads mesh-to-material mappings generated by the Python tools and
## applies the correct .tres materials to each mesh surface.
##
## Usage:
##   godot --headless --script res://godot_converter.gd
##
## Prerequisites:
##   - res://shaders/mesh_material_mapping.json - Maps mesh names to material name arrays
##     (generated by material_list.py)
##   - Pack folders containing:
##     - models/ - Directory containing FBX files to convert
##     - materials/ - Directory containing .tres material files
##
## Output:
##   - {pack}/meshes/ - Individual .tscn scene files (one per MeshInstance3D found)
##     Each scene has a MeshInstance3D root with material overrides pointing to
##     external .tres files, keeping materials editable and reusable.
##
## Pack Discovery:
##   The script auto-discovers pack folders by looking for directories containing
##   both models/ and materials/ subdirectories at the project root.
##
## Collision Handling:
##   Meshes with "collision" in their name or ending with "_col" are saved
##   with a green wireframe StandardMaterial3D for debugging visibility.
##
## @tutorial(User Guide): docs/user-guide.md
## @tutorial(API Reference): docs/api/godot_converter.md

extends SceneTree

## Maps mesh names to arrays of material names.
## Loaded from res://shaders/mesh_material_mapping.json at startup.
## Keys are mesh names (e.g., "SM_Prop_Crystal_01"), values are
## arrays of material names in surface index order.
## @type Dictionary[String, Array[String]]
var mesh_to_materials: Dictionary = {}

## Tracks mesh names that have been saved to detect duplicates across FBX files.
## Keys are output paths, values are true (just used as a set).
## @type Dictionary[String, bool]
var saved_mesh_names: Dictionary = {}

## Counter for successfully converted and saved meshes.
var meshes_saved: int = 0

## Counter for meshes skipped (null mesh, no surfaces, etc.).
var meshes_skipped: int = 0

## Counter for non-fatal warnings (missing materials, duplicates, etc.).
var warnings: int = 0

## Counter for errors that prevented mesh conversion.
var errors: int = 0

## Magenta material applied to collision meshes for debugging visibility.
## Collision meshes are identified by name containing "collision" or ending with "_col".
var collision_material: StandardMaterial3D = null

## Current pack folder being processed (e.g., "res://PolygonNature_SourceFiles").
## Used for resolving material paths relative to the pack.
var current_pack_folder: String = ""

## Default material name for the current pack (e.g., "PolygonFantasyKingdom_Mat_01_A").
## Detected automatically by scanning for *_Mat_01_A.tres files in the materials folder.
## Used as a final fallback when no material mapping exists for a mesh.
var default_material_name: String = ""

## Configuration options loaded from converter_config.json.
## - keep_meshes_together: If true, all meshes from one FBX are saved in a single scene.
## - mesh_format: Output format - "tscn" (text) or "res" (binary).
## - filter_pattern: Optional filter pattern for FBX filenames.
var config_keep_meshes_together: bool = false
var config_mesh_format: String = "tscn"
var config_filter_pattern: String = ""


## Loads configuration options from converter_config.json.
## This JSON file is generated by the Python CLI and contains options like
## keep_meshes_together, mesh_format, and filter_pattern.
## If the file doesn't exist, defaults are used.
##
## @returns bool True if config was loaded (or defaults used), false on parse error.
func load_converter_config() -> bool:
	const CONFIG_PATH := "res://converter_config.json"

	if not FileAccess.file_exists(CONFIG_PATH):
		print("No converter_config.json found, using defaults")
		return true

	var file := FileAccess.open(CONFIG_PATH, FileAccess.READ)
	if file == null:
		push_warning("Failed to open converter_config.json: %s" % error_string(FileAccess.get_open_error()))
		return true  # Use defaults

	var json_text := file.get_as_text()
	file.close()

	var json := JSON.new()
	var parse_result := json.parse(json_text)

	if parse_result != OK:
		printerr("Failed to parse converter_config.json: %s at line %d" % [
			json.get_error_message(),
			json.get_error_line()
		])
		return false

	var data = json.get_data()
	if not data is Dictionary:
		printerr("Invalid config format: expected Dictionary, got %s" % typeof(data))
		return false

	# Load options with defaults
	config_keep_meshes_together = data.get("keep_meshes_together", false)
	config_mesh_format = data.get("mesh_format", "tscn")
	var filter_val = data.get("filter_pattern", null)
	config_filter_pattern = filter_val if filter_val != null else ""

	print("Config loaded:")
	print("  keep_meshes_together: %s" % config_keep_meshes_together)
	print("  mesh_format: %s" % config_mesh_format)
	if not config_filter_pattern.is_empty():
		print("  filter_pattern: %s" % config_filter_pattern)

	return true


## Main entry point. Called when script runs via --script flag.
## Orchestrates the complete FBX-to-TSCN conversion process:
## 1. Loads configuration from converter_config.json
## 2. Loads material mapping from JSON
## 3. Discovers pack folders
## 4. For each pack folder:
##    a. Finds all FBX files in {pack}/models/
##    b. Processes each FBX, extracting meshes and applying materials from {pack}/materials/
##    c. Saves scenes to {pack}/meshes/
## 5. Prints summary and exits with appropriate code
func _init() -> void:
	print("=" .repeat(60))
	print("Synty Shader Converter - FBX to Scene Files")
	print("=" .repeat(60))
	print("")

	# Create wireframe material for collision meshes
	collision_material = StandardMaterial3D.new()
	collision_material.albedo_color = Color(0.0, 1.0, 0.0)  # Green wireframe
	collision_material.shading_mode = BaseMaterial3D.SHADING_MODE_UNSHADED
	collision_material.wireframe = true

	# Load converter configuration
	if not load_converter_config():
		printerr("Failed to parse converter_config.json. Aborting.")
		quit(1)
		return

	# Load the material mapping
	if not load_material_mapping():
		printerr("Failed to load material mapping. Aborting.")
		quit(1)
		return

	# Discover pack folders
	var pack_folders := discover_pack_folders()

	if pack_folders.is_empty():
		print("No pack folders found (directories with models/ and materials/ subdirs)")
		quit(0)
		return

	print("Found %d pack folder(s): %s" % [pack_folders.size(), ", ".join(pack_folders)])
	print("")

	# Process each pack folder
	for pack_folder in pack_folders:
		process_pack_folder(pack_folder)

	print("")
	print_summary()

	# Exit with error code only if no meshes were saved at all
	# Warnings (missing materials, etc.) are expected and shouldn't cause failure
	var exit_code := 0 if meshes_saved > 0 else 1
	quit(exit_code)


## Discovers pack folders at the project root.
## Pack folders are identified by having both models/ and materials/ subdirectories.
## Hidden directories (starting with .) and special directories (.godot, shaders, meshes)
## are skipped.
##
## @returns Array[String] Array of pack folder resource paths (e.g., "res://PackName").
func discover_pack_folders() -> Array[String]:
	var result: Array[String] = []
	var root_dir := DirAccess.open("res://")

	if root_dir == null:
		printerr("Cannot open project root directory")
		return result

	root_dir.list_dir_begin()
	var dir_name := root_dir.get_next()

	while dir_name != "":
		if root_dir.current_is_dir():
			# Skip hidden and special directories
			if not dir_name.begins_with(".") and dir_name != "shaders" and dir_name != "meshes":
				var pack_path := "res://" + dir_name
				var models_path := pack_path + "/models"
				var materials_path := pack_path + "/materials"

				# Check if this is a valid pack folder (has both models and materials)
				if DirAccess.dir_exists_absolute(models_path) and DirAccess.dir_exists_absolute(materials_path):
					result.append(pack_path)

		dir_name = root_dir.get_next()

	root_dir.list_dir_end()
	return result


## Processes a single pack folder, converting all FBX files within it.
##
## @param pack_folder Resource path to the pack folder (e.g., "res://PolygonNature_SourceFiles").
func process_pack_folder(pack_folder: String) -> void:
	print("Processing pack: %s" % pack_folder)
	current_pack_folder = pack_folder

	# Detect default material for this pack
	var materials_path := pack_folder + "/materials"
	default_material_name = _detect_default_material(materials_path)
	if not default_material_name.is_empty():
		print("  Default material: %s" % default_material_name)
	else:
		print("  No default material found (no *_Mat_01_A.tres files)")

	var models_path := pack_folder + "/models"
	var meshes_output := pack_folder + "/meshes"

	# Ensure output directory exists
	_ensure_directory_exists(meshes_output)

	# Find all FBX files in the pack's models directory
	var fbx_files := find_fbx_files(models_path)

	if fbx_files.is_empty():
		print("  No FBX files found in %s" % models_path)
		return

	var total_fbx := fbx_files.size()
	print("  Found %d FBX file(s) to process" % total_fbx)

	for i in range(fbx_files.size()):
		var fbx_path := fbx_files[i]
		print("[%d/%d] Processing: %s" % [i + 1, total_fbx, fbx_path.get_file()])
		process_fbx_file(fbx_path)


## Loads the mesh-to-material mapping from JSON file.
## The JSON file maps mesh names to arrays of material names.
## This mapping is generated by the Python material_list.py tool.
##
## @returns bool True if loading succeeded, false otherwise.
func load_material_mapping() -> bool:
	const MAPPING_PATH := "res://shaders/mesh_material_mapping.json"

	if not FileAccess.file_exists(MAPPING_PATH):
		printerr("Material mapping file not found: %s" % MAPPING_PATH)
		return false

	var file := FileAccess.open(MAPPING_PATH, FileAccess.READ)
	if file == null:
		printerr("Failed to open mapping file: %s (error: %s)" % [
			MAPPING_PATH,
			error_string(FileAccess.get_open_error())
		])
		return false

	var json_text := file.get_as_text()
	file.close()

	var json := JSON.new()
	var parse_result := json.parse(json_text)

	if parse_result != OK:
		printerr("Failed to parse JSON: %s at line %d" % [
			json.get_error_message(),
			json.get_error_line()
		])
		return false

	var data = json.get_data()
	if not data is Dictionary:
		printerr("Invalid mapping format: expected Dictionary, got %s" % typeof(data))
		return false

	mesh_to_materials = data
	print("Loaded material mapping with %d mesh entries" % mesh_to_materials.size())

	return true


## Recursively finds all FBX files in the given directory.
## Searches subdirectories and returns paths to all .fbx files found.
## Hidden directories (starting with .) are skipped.
## If config_filter_pattern is set, only files containing the pattern are returned.
##
## @param dir_path Resource path to search (e.g., "res://PackName/models").
## @returns Array[String] Array of FBX file paths found.
func find_fbx_files(dir_path: String) -> Array[String]:
	var result: Array[String] = []
	var dir := DirAccess.open(dir_path)

	if dir == null:
		push_warning("Cannot open directory: %s (error: %s)" % [
			dir_path,
			error_string(DirAccess.get_open_error())
		])
		return result

	dir.list_dir_begin()
	var file_name := dir.get_next()

	while file_name != "":
		var full_path := dir_path.path_join(file_name)

		if dir.current_is_dir():
			# Skip hidden directories
			if not file_name.begins_with("."):
				# Recursively search subdirectories
				result.append_array(find_fbx_files(full_path))
		else:
			# Check for FBX files (case-insensitive)
			if file_name.to_lower().ends_with(".fbx"):
				# Apply filter pattern if set
				if config_filter_pattern.is_empty():
					result.append(full_path)
				else:
					# Case-insensitive pattern matching
					var base_name := file_name.get_basename()
					if base_name.to_lower().contains(config_filter_pattern.to_lower()):
						result.append(full_path)

		file_name = dir.get_next()

	dir.list_dir_end()
	return result


## Processes a single FBX file, extracting meshes based on config.
## Loads the FBX as a PackedScene, finds all MeshInstance3D nodes,
## and either saves each as individual scene files (default) or keeps
## them together in a single scene (when keep_meshes_together is true).
##
## @param fbx_path Resource path to the FBX file (e.g., "res://PackName/models/Props.fbx").
func process_fbx_file(fbx_path: String) -> void:
	var fbx_name := fbx_path.get_file().get_basename()
	print("  Processing: %s" % fbx_path)

	# Determine relative directory for output (mirror models/ structure in meshes/)
	var models_prefix := current_pack_folder + "/models/"
	var relative_path := fbx_path.trim_prefix(models_prefix)
	var relative_dir := relative_path.get_base_dir()

	# Load the FBX as a PackedScene
	var packed_scene: PackedScene = load(fbx_path)
	if packed_scene == null:
		printerr("    ERROR: Failed to load FBX: %s" % fbx_path)
		errors += 1
		return

	# Instantiate the scene to traverse it
	var scene_instance: Node = packed_scene.instantiate()
	if scene_instance == null:
		printerr("    ERROR: Failed to instantiate scene: %s" % fbx_path)
		errors += 1
		return

	# Find all MeshInstance3D nodes
	var mesh_instances := find_mesh_instances(scene_instance)

	if mesh_instances.is_empty():
		print("    No meshes found in FBX")
		scene_instance.free()
		return

	print("    Found %d mesh(es)" % mesh_instances.size())

	if config_keep_meshes_together:
		# Keep all meshes together in a single scene file
		save_fbx_as_single_scene(scene_instance, mesh_instances, relative_dir, fbx_name)
	else:
		# Extract and save each mesh separately (default behavior)
		for mesh_instance in mesh_instances:
			extract_and_save_mesh(mesh_instance, relative_dir, fbx_name)

	# Clean up
	scene_instance.free()


## Saves all meshes from an FBX as a single scene file.
## Applies materials to all mesh instances and saves the entire scene tree.
## Used when --keep-meshes-together is enabled.
##
## @param scene_root The root node of the FBX scene.
## @param mesh_instances Array of all MeshInstance3D nodes to process.
## @param relative_dir Subdirectory path relative to meshes/ for output.
## @param fbx_name Name of the FBX file (used as scene name).
func save_fbx_as_single_scene(scene_root: Node, mesh_instances: Array[MeshInstance3D], relative_dir: String, fbx_name: String) -> void:
	var materials_dir := current_pack_folder + "/materials"
	var materials_applied := 0

	# Apply materials to each mesh instance
	for mesh_instance in mesh_instances:
		var mesh_name := String(mesh_instance.name)
		var original_mesh := mesh_instance.mesh

		if original_mesh == null or original_mesh.get_surface_count() == 0:
			continue

		# Check if this is a collision mesh
		var is_collision := mesh_name.to_lower().contains("collision") or mesh_name.to_lower().ends_with("_col")

		if is_collision:
			# Apply green wireframe material
			for i in range(original_mesh.get_surface_count()):
				mesh_instance.set_surface_override_material(i, collision_material)
			continue

		# Get materials for this mesh
		var material_names := get_material_names_for_mesh(mesh_name)

		# Apply materials as overrides
		for i in range(original_mesh.get_surface_count()):
			if i < material_names.size() and material_names[i] != "":
				var mat_name := material_names[i]
				var material_path := find_material_path(mat_name, materials_dir)

				if material_path.is_empty():
					print("      Warning: Material not found: %s" % mat_name)
					warnings += 1
					continue

				var material: Material = load(material_path)
				if material == null:
					print("      Warning: Failed to load material: %s" % material_path)
					warnings += 1
					continue

				mesh_instance.set_surface_override_material(i, material)
				materials_applied += 1

	# Determine output path
	var meshes_dir := current_pack_folder + "/meshes"
	var output_path: String
	var file_ext := "." + config_mesh_format

	if relative_dir.is_empty():
		output_path = "%s/%s%s" % [meshes_dir, fbx_name, file_ext]
	else:
		output_path = "%s/%s/%s%s" % [meshes_dir, relative_dir, fbx_name, file_ext]

	# Ensure output directory exists
	_ensure_directory_exists(output_path.get_base_dir())

	# Create a new root node (Node3D) with proper ownership for all children
	var new_root := Node3D.new()
	new_root.name = fbx_name

	# Duplicate children and add to new root with proper ownership
	for child in scene_root.get_children():
		var duplicated := child.duplicate()
		new_root.add_child(duplicated)
		_set_owner_recursive(duplicated, new_root)

	# Pack and save
	var scene := PackedScene.new()
	var pack_result := scene.pack(new_root)

	if pack_result != OK:
		printerr("      ERROR: Failed to pack scene: %s (error: %s)" % [
			output_path,
			error_string(pack_result)
		])
		new_root.free()
		errors += 1
		return

	var save_result := ResourceSaver.save(scene, output_path)
	new_root.free()

	if save_result != OK:
		printerr("      ERROR: Failed to save scene: %s (error: %s)" % [
			output_path,
			error_string(save_result)
		])
		errors += 1
		return

	print("      Saved combined scene: %s (%d meshes, %d materials)" % [
		output_path.get_file(), mesh_instances.size(), materials_applied
	])
	meshes_saved += 1


## Recursively sets the owner of a node and all its children.
## Required for PackedScene.pack() to include all nodes in the saved scene.
##
## @param node The node to set ownership on.
## @param owner The owner node (typically the scene root).
func _set_owner_recursive(node: Node, owner: Node) -> void:
	node.owner = owner
	for child in node.get_children():
		_set_owner_recursive(child, owner)


## Recursively finds all MeshInstance3D nodes in the scene tree.
## Traverses the entire node hierarchy starting from the given node.
##
## @param node Root node to search from.
## @returns Array[MeshInstance3D] All MeshInstance3D nodes found in the subtree.
func find_mesh_instances(node: Node) -> Array[MeshInstance3D]:
	var result: Array[MeshInstance3D] = []

	if node is MeshInstance3D:
		result.append(node as MeshInstance3D)

	for child in node.get_children():
		result.append_array(find_mesh_instances(child))

	return result


## Extracts mesh from MeshInstance3D, applies materials, and saves as .tscn.
## Creates a new scene with the mesh and material overrides pointing to
## external .tres files. Collision meshes get magenta material for visibility.
##
## @param mesh_instance The MeshInstance3D to extract.
## @param relative_dir Subdirectory path relative to meshes/ for output.
## @param fbx_name Name of source FBX (used for duplicate name resolution).
func extract_and_save_mesh(mesh_instance: MeshInstance3D, relative_dir: String, fbx_name: String) -> void:
	var mesh_name := String(mesh_instance.name)
	var original_mesh := mesh_instance.mesh

	if original_mesh == null:
		print("      Skipping %s (null mesh)" % mesh_name)
		meshes_skipped += 1
		return

	if original_mesh.get_surface_count() == 0:
		print("      Skipping %s (no surfaces)" % mesh_name)
		meshes_skipped += 1
		return

	# Check if this is a collision mesh - apply green wireframe material
	var is_collision := mesh_name.to_lower().contains("collision") or mesh_name.to_lower().ends_with("_col")

	# Create a MeshInstance3D node for the scene
	var scene_mesh_instance := MeshInstance3D.new()
	scene_mesh_instance.mesh = original_mesh  # Use original mesh (no need to duplicate)
	scene_mesh_instance.name = mesh_name

	# Determine base output path using current pack folder
	var meshes_dir := current_pack_folder + "/meshes"
	var file_ext := "." + config_mesh_format
	var output_path: String
	if relative_dir.is_empty():
		output_path = "%s/%s%s" % [meshes_dir, mesh_name, file_ext]
	else:
		output_path = "%s/%s/%s%s" % [meshes_dir, relative_dir, mesh_name, file_ext]

	if is_collision:
		# Apply green wireframe material as override for visibility
		for i in range(original_mesh.get_surface_count()):
			scene_mesh_instance.set_surface_override_material(i, collision_material)

		_ensure_directory_exists(output_path.get_base_dir())

		# Pack and save as scene
		var scene := PackedScene.new()
		var pack_result := scene.pack(scene_mesh_instance)
		if pack_result != OK:
			printerr("      ERROR: Failed to pack collision scene: %s" % mesh_name)
			scene_mesh_instance.free()
			errors += 1
			return

		var save_result := ResourceSaver.save(scene, output_path)
		scene_mesh_instance.free()

		if save_result == OK:
			print("      Saved collision: %s (green wireframe)" % mesh_name)
			meshes_saved += 1
		else:
			printerr("      ERROR: Failed to save collision scene: %s" % mesh_name)
			errors += 1
		return  # Skip normal material lookup

	# Get materials for this mesh (loaded as external resources)
	var material_names := get_material_names_for_mesh(mesh_name)
	var materials_applied := 0

	# Apply materials as overrides (references to external .tres files, not baked in)
	# Materials are in the current pack's materials/ folder
	var materials_dir := current_pack_folder + "/materials"
	for i in range(original_mesh.get_surface_count()):
		if i < material_names.size() and material_names[i] != "":
			var mat_name := material_names[i]
			# Use fallback logic to find material (handles prefix mismatches)
			var material_path := find_material_path(mat_name, materials_dir)

			if material_path.is_empty():
				print("      Warning: Material not found: %s (tried fallbacks)" % mat_name)
				warnings += 1
				continue

			var material: Material = load(material_path)
			if material == null:
				print("      Warning: Failed to load material: %s" % material_path)
				warnings += 1
				continue

			scene_mesh_instance.set_surface_override_material(i, material)
			materials_applied += 1

	# Handle duplicate mesh names by appending FBX source name
	if saved_mesh_names.has(output_path):
		# Mesh with this name already saved from a different FBX
		var unique_name := "%s_%s" % [mesh_name, fbx_name]
		if relative_dir.is_empty():
			output_path = "%s/%s%s" % [meshes_dir, unique_name, file_ext]
		else:
			output_path = "%s/%s/%s%s" % [meshes_dir, relative_dir, unique_name, file_ext]
		print("      Note: Renamed to %s (duplicate name)" % unique_name)
		warnings += 1

	# Ensure output directory exists
	var output_dir := output_path.get_base_dir()
	_ensure_directory_exists(output_dir)

	# Pack and save as scene
	var scene := PackedScene.new()
	var pack_result := scene.pack(scene_mesh_instance)

	if pack_result != OK:
		printerr("      ERROR: Failed to pack scene: %s (error: %s)" % [
			output_path,
			error_string(pack_result)
		])
		scene_mesh_instance.free()
		errors += 1
		return

	var save_result := ResourceSaver.save(scene, output_path)

	# Clean up the temporary node
	scene_mesh_instance.free()

	if save_result != OK:
		printerr("      ERROR: Failed to save scene: %s (error: %s)" % [
			output_path,
			error_string(save_result)
		])
		errors += 1
		return

	# Track saved mesh name
	saved_mesh_names[output_path] = true

	if materials_applied > 0:
		print("      Saved: %s (%d materials)" % [output_path.get_file(), materials_applied])
	else:
		print("      Saved: %s (no materials)" % output_path.get_file())

	meshes_saved += 1


## Looks up material names for a mesh by name.
## Tries exact match first, then strips numeric suffixes added by Godot import
## (like "_001", "_002"). If still not found, tries various fallback patterns
## for common naming conventions (SK_ to SM_, _Static suffix, etc.).
##
## @param mesh_name The mesh name to look up (e.g., "SM_Prop_Crystal_01_001").
## @returns Array[String] Material names for each surface. May contain empty strings
##          for surfaces with no material mapping. Empty array if mesh not found.
func get_material_names_for_mesh(mesh_name: String) -> Array[String]:
	var material_names_result: Array[String] = []
	var lookup_name := mesh_name

	# Try exact match first
	if not mesh_to_materials.has(lookup_name):
		# Try stripping numeric suffixes like "_001", "_002" (Godot import adds these)
		var base_name := _strip_numeric_suffix(mesh_name)
		if base_name != mesh_name and mesh_to_materials.has(base_name):
			lookup_name = base_name
		else:
			# Try fallback patterns for common naming mismatches
			var fallback_name := _try_material_fallbacks(base_name if base_name != mesh_name else mesh_name)
			if not fallback_name.is_empty():
				lookup_name = fallback_name
			else:
				# Final fallback: use default material if available
				if not default_material_name.is_empty():
					print("      Using default material for mesh '%s': %s" % [mesh_name, default_material_name])
					material_names_result.append(default_material_name)
					return material_names_result
				else:
					print("      Warning: No material mapping for mesh '%s'" % mesh_name)
					warnings += 1
					return material_names_result

	var material_names = mesh_to_materials[lookup_name]

	# Handle both array and single string formats
	if material_names is String:
		material_names = [material_names]

	if not material_names is Array:
		print("      Warning: Invalid material format for mesh '%s'" % lookup_name)
		warnings += 1
		return material_names_result

	# Collect material names
	for material_name in material_names:
		if material_name is String and not material_name.is_empty():
			material_names_result.append(material_name)
		else:
			# Empty material name - append empty string to preserve surface index alignment
			material_names_result.append("")

	return material_names_result


## Tries fallback patterns to find material mapping for a mesh name.
## This handles common naming mismatches in Synty asset packs where mesh
## names in FBX files differ from their MaterialList.txt entries.
##
## Fallback order:
## 1. SK_ to SM_ conversion (skeletal meshes often share materials with static meshes)
## 2. Remove _Static suffix (static variants use base mesh materials)
## 3. Remove _Preset suffix (preset variants use base mesh materials)
## 4. Remove sub-component suffixes (_Cork, _Liquid, _Handle, _Door_X, _Drawer_X, etc.)
##
## @param mesh_name The mesh name to find fallbacks for.
## @returns String The fallback mesh name that was found in the mapping, or empty string if none found.
func _try_material_fallbacks(mesh_name: String) -> String:
	# Fallback 1: SK_ to SM_ conversion
	# Skeletal meshes (SK_) often share materials with their static mesh (SM_) counterparts
	if mesh_name.begins_with("SK_"):
		var sm_name := "SM_" + mesh_name.substr(3)
		if mesh_to_materials.has(sm_name):
			print("      Fallback: '%s' -> '%s' (SK_ to SM_)" % [mesh_name, sm_name])
			return sm_name

	# Fallback 2: Remove _Static suffix
	# Static variants (e.g., "SM_Prop_Barrel_Static") use base mesh materials ("SM_Prop_Barrel")
	if mesh_name.ends_with("_Static"):
		var base_name := mesh_name.substr(0, mesh_name.length() - 7)  # len("_Static") = 7
		if mesh_to_materials.has(base_name):
			print("      Fallback: '%s' -> '%s' (removed _Static)" % [mesh_name, base_name])
			return base_name

	# Fallback 3: Remove _Preset suffix
	# Preset variants use base mesh materials
	if mesh_name.ends_with("_Preset"):
		var base_name := mesh_name.substr(0, mesh_name.length() - 7)  # len("_Preset") = 7
		if mesh_to_materials.has(base_name):
			print("      Fallback: '%s' -> '%s' (removed _Preset)" % [mesh_name, base_name])
			return base_name

	# Fallback 4: Remove sub-component suffixes
	# Sub-components like _Cork, _Liquid, _Handle use the parent mesh's materials
	var component_suffixes: Array[String] = [
		"_Cork", "_Liquid", "_Handle",
		"_Door_1", "_Door_2", "_Door_01", "_Door_02",
		"_Drawer_01", "_Drawer_02", "_Drawer_03",
		"_Chains_01", "_Chains_02",
		"_Arrow_01", "_Arrow_02", "_Arrow_03"
	]

	for suffix in component_suffixes:
		if mesh_name.ends_with(suffix):
			var base_name := mesh_name.substr(0, mesh_name.length() - suffix.length())
			if mesh_to_materials.has(base_name):
				print("      Fallback: '%s' -> '%s' (removed %s)" % [mesh_name, base_name, suffix])
				return base_name

	# No fallback found
	return ""


## Strips numeric suffixes like "_001", "_01", "001" from a name.
## Godot's FBX importer adds numeric suffixes to duplicate node names.
## This allows matching meshes even when suffixes are present.
##
## @param name The name to strip suffix from.
## @returns String The name without trailing numeric suffix.
func _strip_numeric_suffix(name: String) -> String:
	var regex := RegEx.new()
	regex.compile("(_?\\d+)$")
	return regex.sub(name, "")


## Detects the default material for a pack by scanning for *_Mat_01_A.tres files.
## The pattern is typically Polygon{PackName}_Mat_01_A, which is the base material
## used by most meshes in Synty packs.
##
## @param materials_dir Path to the materials directory to scan.
## @returns String The default material name (without .tres extension), or empty string if not found.
func _detect_default_material(materials_dir: String) -> String:
	var dir := DirAccess.open(materials_dir)
	if dir == null:
		return ""

	dir.list_dir_begin()
	var file_name := dir.get_next()

	while file_name != "":
		if not dir.current_is_dir():
			# Check for *_Mat_01_A.tres pattern (case-insensitive check)
			if file_name.to_lower().ends_with(".tres"):
				var base_name := file_name.get_basename()
				if base_name.ends_with("_Mat_01_A"):
					dir.list_dir_end()
					return base_name

		file_name = dir.get_next()

	dir.list_dir_end()
	return ""


## Tries to find a material file with fallback for naming mismatches.
## MaterialList.txt often references materials with full prefixes like
## "PolygonFantasyKingdom_Mat_Castle_Wall_01" but the generated .tres files
## are named with just the suffix part like "Castle_Wall_01.tres".
##
## Fallback order:
## 1. Exact name match
## 2. Strip Polygon*_Mat_ prefix (e.g., PolygonFantasyKingdom_Mat_Glass -> Glass)
## 3. Strip Polygon*_ prefix (e.g., PolygonNature_Tree -> Tree)
## 4. Try with _01 suffix if not already present
##
## @param mat_name The material name from the mapping (may have full prefix).
## @param materials_dir Path to the materials directory to search in.
## @returns String Full path to the material file if found, empty string otherwise.
func find_material_path(mat_name: String, materials_dir: String) -> String:
	var base_path := materials_dir.path_join(mat_name + ".tres")

	# 1. Try exact name
	# NOTE: Use ResourceLoader.exists() instead of FileAccess.file_exists() for res:// paths.
	# FileAccess.file_exists() has known issues with resource paths, especially:
	# - During headless execution in _init()
	# - With .remap files created by Godot's import system
	if ResourceLoader.exists(base_path):
		return base_path

	# 2. Strip Polygon*_Mat_ or Polygon*_ prefix
	var stripped := mat_name
	if stripped.begins_with("Polygon"):
		# Try to find _Mat_ first (e.g., PolygonFantasyKingdom_Mat_Glass -> Glass)
		var mat_idx := stripped.find("_Mat_")
		if mat_idx > 0:
			stripped = stripped.substr(mat_idx + 5)  # len("_Mat_") = 5
		else:
			# Try just first underscore after Polygon prefix (e.g., PolygonNature_Tree -> Tree)
			var first_underscore := stripped.find("_")
			if first_underscore > 0:
				stripped = stripped.substr(first_underscore + 1)

	# 3. Try stripped name
	var stripped_path := materials_dir.path_join(stripped + ".tres")
	if ResourceLoader.exists(stripped_path):
		return stripped_path

	# 4. Try with _01 suffix if not already present
	if not stripped.ends_with("_01"):
		var with_suffix_path := materials_dir.path_join(stripped + "_01.tres")
		if ResourceLoader.exists(with_suffix_path):
			return with_suffix_path

	# 5. Not found
	return ""


## Ensures a directory exists, creating it recursively if necessary.
## Silently succeeds if directory already exists. Logs warning on failure.
##
## @param dir_path Directory path to create (e.g., "res://PackName/meshes/props").
func _ensure_directory_exists(dir_path: String) -> void:
	if DirAccess.dir_exists_absolute(dir_path):
		return

	var result := DirAccess.make_dir_recursive_absolute(dir_path)
	if result != OK:
		push_warning("Failed to create directory: %s (error: %s)" % [
			dir_path,
			error_string(result)
		])


## Prints a summary of the conversion process.
## Shows counts of saved meshes, skipped meshes, warnings, and errors.
## Provides a final status message based on results.
func print_summary() -> void:
	print("=" .repeat(60))
	print("Conversion Complete")
	print("=" .repeat(60))
	print("  Output format:  .%s" % config_mesh_format)
	if config_keep_meshes_together:
		print("  Mode:           Combined scenes (one per FBX)")
	else:
		print("  Mode:           Individual meshes")
	print("  Meshes saved:   %d" % meshes_saved)
	print("  Meshes skipped: %d" % meshes_skipped)
	print("  Warnings:       %d" % warnings)
	print("  Errors:         %d" % errors)
	print("=" .repeat(60))

	if errors > 0:
		print("")
		print("Some meshes failed to save. Check errors above.")
	elif warnings > 0:
		print("")
		print("Conversion completed with warnings. Check logs above.")
	else:
		print("")
		print("All meshes converted successfully!")
