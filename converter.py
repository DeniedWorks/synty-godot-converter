#!/usr/bin/env python3
"""
Synty Shader Converter - Main CLI Entry Point.

This module orchestrates the full conversion pipeline for converting
Unity Synty assets to Godot 4.6 format.

Usage:
    python converter.py \\
        --unity-package "path/to/.unitypackage" \\
        --source-files "path/to/SourceFiles" \\
        --output "path/to/output" \\
        --godot "path/to/Godot.exe" \\
        --dry-run \\
        --verbose

Pipeline Steps:
    1. Validate inputs (package exists, source-files has Textures/, godot exists)
    2. Create output directory structure
    3. Extract Unity package
    4. Parse all .mat files
    5. Detect shaders and map properties
    6. Generate .tres files
    7. Copy .gdshader files
    8. Copy required textures
    9. Parse MaterialList.txt (if exists)
    10. Generate mesh_material_mapping.json
    11. Generate project.godot with global shader uniforms
    12. Print conversion summary
"""

from __future__ import annotations

import argparse
import logging
import shutil
import subprocess
import sys
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path

# Local imports
from unity_package import extract_unitypackage, GuidMap, get_material_guids, get_material_name
from unity_parser import parse_material_bytes, UnityMaterial
from shader_mapping import map_material, detect_shader_type, MappedMaterial
from tres_generator import generate_tres, write_tres_file, sanitize_filename
from material_list import parse_material_list, generate_mesh_material_mapping_json

logger = logging.getLogger(__name__)

# Shader files to copy from project's shaders/ directory
SHADER_FILES = [
    "clouds.gdshader",
    "crystal.gdshader",
    "foliage.gdshader",
    "particles.gdshader",
    "polygon.gdshader",
    "skydome.gdshader",
    "water.gdshader",
]

# Supported texture extensions (for finding textures by name)
TEXTURE_EXTENSIONS = [".png", ".tga", ".jpg", ".jpeg", ".PNG", ".TGA", ".JPG", ".JPEG"]

# Patterns for finding the pack's main texture atlas (fallback for missing generic textures)
# Order matters - first match wins. Prefer "Polygon" prefixed textures as they're the main atlas.
FALLBACK_TEXTURE_PATTERNS = [
    "Polygon*_Texture_01.png",     # Most common: PolygonNature_Texture_01.png
    "Polygon*_Texture_01_A.png",   # Some packs use _A suffix
    "POLYGON*_Texture_01.png",     # Uppercase variant
    "*_Texture_01_A.png",          # Fallback: any pack with _A suffix
    "Texture_01.png",              # Simple naming
]

# project.godot template with global shader uniforms
PROJECT_GODOT_TEMPLATE = """; Engine configuration file.
; Generated by Synty Shader Converter

[application]

config/name="Synty Converted Assets"
config/features=PackedStringArray("4.6")

[shader_globals]

WindDirection={
"type": "vec3",
"value": Vector3(1, 0, 0)
}
WindIntensity={
"type": "float",
"value": 0.5
}
GaleStrength={
"type": "float",
"value": 0.0
}
MainLightDirection={
"type": "vec3",
"value": Vector3(0.5, -0.5, 0.0)
}
SkyColor={
"type": "color",
"value": Color(0.5, 0.7, 1.0, 1.0)
}
EquatorColor={
"type": "color",
"value": Color(1.0, 0.9, 0.8, 1.0)
}
GroundColor={
"type": "color",
"value": Color(0.4, 0.4, 0.3, 1.0)
}
OceanWavesGradient={
"type": "sampler2D",
"value": ""
}
"""


@dataclass
class ConversionConfig:
    """Configuration dataclass for the conversion pipeline.

    This dataclass holds all configuration options needed to run the
    Unity-to-Godot conversion process. It is populated from command-line
    arguments via parse_args().

    Attributes:
        unity_package: Path to the .unitypackage file to convert. Must exist.
        source_files: Path to SourceFiles directory containing Textures/ and FBX/
            subdirectories. The Textures/ subdirectory must exist.
        output_dir: Output directory for converted Godot assets. Will be created
            if it does not exist.
        godot_exe: Path to Godot 4.6 executable for CLI operations. Must exist.
        dry_run: If True, preview operations without writing files. Useful for
            testing what the conversion would do.
        verbose: If True, enable DEBUG logging level for detailed output.
        skip_fbx_copy: If True, skip copying FBX files from SourceFiles/FBX.
            Use this if the models/ directory is already populated.
        skip_godot_cli: If True, skip Godot CLI conversion phase. This generates
            materials only without producing .tscn scene files.
        godot_timeout: Timeout in seconds for Godot CLI operations. Each phase
            (import and convert) has this timeout applied separately.

    Example:
        >>> config = ConversionConfig(
        ...     unity_package=Path("C:/SyntyAssets/Nature.unitypackage"),
        ...     source_files=Path("C:/SyntyAssets/SourceFiles"),
        ...     output_dir=Path("C:/Godot/Projects/converted"),
        ...     godot_exe=Path("C:/Godot/Godot_v4.6.exe"),
        ...     dry_run=True,  # Preview only
        ...     verbose=True,  # Detailed logging
        ... )
    """

    unity_package: Path
    source_files: Path
    output_dir: Path
    godot_exe: Path
    dry_run: bool = False
    verbose: bool = False
    skip_fbx_copy: bool = False
    skip_godot_cli: bool = False
    godot_timeout: int = 600


@dataclass
class ConversionStats:
    """Statistics collected during the conversion pipeline.

    This dataclass tracks all metrics and issues encountered during conversion.
    It is populated by run_conversion() and used to generate the final summary
    and conversion log.

    Attributes:
        materials_parsed: Number of Unity .mat files successfully parsed from
            the unitypackage. Incremented in Step 4 of the pipeline.
        materials_generated: Number of Godot .tres material files written to
            output/materials/. Includes both converted and placeholder materials.
        textures_copied: Number of texture files successfully copied from
            SourceFiles/Textures to output/textures/.
        textures_fallback: Number of missing textures substituted with the pack's
            main texture atlas (e.g., Texture_01.png) as a fallback.
        textures_missing: Number of textures referenced by materials but not
            found in the source directory and no fallback was available.
        shaders_copied: Number of .gdshader files copied to output/shaders/.
            Should equal len(SHADER_FILES) if all shaders are present.
        fbx_copied: Number of FBX model files copied from SourceFiles/FBX to
            output/models/.
        fbx_skipped: Number of FBX files skipped because they already existed
            at the destination with the same file size.
        meshes_converted: Number of .tscn scene files generated by Godot CLI.
            Counted from output/meshes/ after conversion.
        godot_import_success: True if Godot --import phase completed without
            error. False if it failed or was skipped.
        godot_convert_success: True if godot_converter.gd script completed
            successfully. False if it failed or was skipped.
        godot_timeout_occurred: True if either Godot CLI phase exceeded the
            configured timeout.
        warnings: List of warning messages for non-critical issues (e.g.,
            missing textures, parse failures for individual materials).
        errors: List of error messages for critical failures that may have
            stopped the conversion or indicate incomplete output.

    Example:
        >>> stats = ConversionStats()
        >>> stats.materials_parsed = 42
        >>> stats.textures_copied = 15
        >>> stats.warnings.append("Texture 'Missing_Tex' not found")
        >>> print(f"Parsed {stats.materials_parsed} materials")
        Parsed 42 materials
    """

    materials_parsed: int = 0
    materials_generated: int = 0
    textures_copied: int = 0
    textures_fallback: int = 0
    textures_missing: int = 0
    shaders_copied: int = 0
    fbx_copied: int = 0
    fbx_skipped: int = 0
    meshes_converted: int = 0
    godot_import_success: bool = False
    godot_convert_success: bool = False
    godot_timeout_occurred: bool = False
    warnings: list[str] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)


def parse_args() -> ConversionConfig:
    """Parse command-line arguments and validate inputs.

    Returns:
        ConversionConfig with validated paths.

    Raises:
        SystemExit: If required arguments are missing or invalid.
    """
    parser = argparse.ArgumentParser(
        description="Convert Synty Unity assets to Godot 4.6 format.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python converter.py \\
        --unity-package "C:/SyntyComplete/PolygonNature/Nature.unitypackage" \\
        --source-files "C:/SyntyComplete/PolygonNature/SourceFiles" \\
        --output "C:/Godot/Projects/converted_nature" \\
        --godot "C:/Godot/Godot_v4.6.exe"

    python converter.py \\
        --unity-package package.unitypackage \\
        --source-files ./SourceFiles \\
        --output ./output \\
        --godot godot.exe \\
        --dry-run --verbose
""",
    )

    parser.add_argument(
        "--unity-package",
        type=Path,
        required=True,
        help="Path to Unity .unitypackage file",
    )
    parser.add_argument(
        "--source-files",
        type=Path,
        required=True,
        help="Path to SourceFiles folder containing Textures/ and FBX/",
    )
    parser.add_argument(
        "--output",
        type=Path,
        required=True,
        help="Output directory for Godot project",
    )
    parser.add_argument(
        "--godot",
        type=Path,
        required=True,
        help="Path to Godot 4.6 executable",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview without writing files",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose logging",
    )
    parser.add_argument(
        "--skip-fbx-copy",
        action="store_true",
        help="Skip copying FBX files (use if models/ already populated)",
    )
    parser.add_argument(
        "--skip-godot-cli",
        action="store_true",
        help="Skip running Godot CLI (generates materials only, no .tscn scene files)",
    )
    parser.add_argument(
        "--godot-timeout",
        type=int,
        default=600,
        help="Timeout for Godot CLI operations in seconds (default: 600)",
    )

    args = parser.parse_args()

    # Validate paths
    if not args.unity_package.exists():
        parser.error(f"Unity package not found: {args.unity_package}")

    if not args.source_files.exists():
        parser.error(f"Source files directory not found: {args.source_files}")

    textures_dir = args.source_files / "Textures"
    if not textures_dir.exists():
        parser.error(f"Textures directory not found: {textures_dir}")

    if not args.godot.exists():
        parser.error(f"Godot executable not found: {args.godot}")

    return ConversionConfig(
        unity_package=args.unity_package.resolve(),
        source_files=args.source_files.resolve(),
        output_dir=args.output.resolve(),
        godot_exe=args.godot.resolve(),
        dry_run=args.dry_run,
        verbose=args.verbose,
        skip_fbx_copy=args.skip_fbx_copy,
        skip_godot_cli=args.skip_godot_cli,
        godot_timeout=args.godot_timeout,
    )


def setup_output_directories(output_dir: Path, dry_run: bool) -> None:
    """Create the output directory structure.

    Creates:
        output_dir/
            shaders/
            textures/
            materials/
            models/
            meshes/

    Args:
        output_dir: Root output directory.
        dry_run: If True, only log what would be created.
    """
    directories = [
        output_dir,
        output_dir / "shaders",
        output_dir / "textures",
        output_dir / "materials",
        output_dir / "models",
        output_dir / "meshes",
    ]

    for directory in directories:
        if dry_run:
            logger.info("[DRY RUN] Would create directory: %s", directory)
        else:
            directory.mkdir(parents=True, exist_ok=True)
            logger.debug("Created directory: %s", directory)


def copy_shaders(source_dir: Path, output_dir: Path, dry_run: bool) -> int:
    """Copy .gdshader files from project's shaders/ to output/shaders/.

    Args:
        source_dir: Directory containing the converter project (with shaders/ subfolder).
        output_dir: Output directory (shaders will be copied to output_dir/shaders/).
        dry_run: If True, only log what would be copied.

    Returns:
        Number of shader files copied (or would be copied in dry run).
    """
    # Source shaders are relative to where this script is located
    script_dir = Path(__file__).parent
    shaders_source = script_dir / "shaders"
    shaders_dest = output_dir / "shaders"

    copied = 0
    for shader_file in SHADER_FILES:
        source_path = shaders_source / shader_file
        dest_path = shaders_dest / shader_file

        if not source_path.exists():
            logger.warning("Shader file not found: %s", source_path)
            continue

        if dry_run:
            logger.info("[DRY RUN] Would copy shader: %s -> %s", source_path, dest_path)
        else:
            shutil.copy2(source_path, dest_path)
            logger.debug("Copied shader: %s", shader_file)

        copied += 1

    logger.info("Copied %d shader files", copied)
    return copied


def find_fallback_texture(textures_dir: Path) -> Path | None:
    """Find the pack's main texture atlas to use as fallback for missing textures.

    Searches for common Synty texture atlas naming patterns in the root of
    the textures directory. Every Synty pack has a main color palette texture
    (e.g., PolygonNature_Texture_01.png) that can be used as a fallback.

    Args:
        textures_dir: Path to the SourceFiles/Textures directory.

    Returns:
        Path to the fallback texture if found, None otherwise.
    """
    for pattern in FALLBACK_TEXTURE_PATTERNS:
        # Only search in root directory, not subdirectories
        matches = list(textures_dir.glob(pattern))
        if matches:
            # Return first match (prefer shorter names)
            matches.sort(key=lambda p: len(p.name))
            logger.debug("Found fallback texture: %s", matches[0].name)
            return matches[0]

    return None


def find_texture_file(textures_dir: Path, texture_name: str) -> Path | None:
    """Find a texture file by name, trying various extensions.

    Searches for a texture file first in the root of textures_dir, then
    recursively in subdirectories. Tries all extensions in TEXTURE_EXTENSIONS.

    Args:
        textures_dir: Directory to search for textures (e.g., SourceFiles/Textures).
        texture_name: Base name of the texture. May include extension (which
            will be stripped) or be just the stem (e.g., "PolygonNature_01").

    Returns:
        Path to the first matching texture file if found, None otherwise.
        Prefers files in the root directory over subdirectories.

    Example:
        >>> path = find_texture_file(Path("Textures"), "Ground_01")
        >>> print(path)
        Textures/Ground_01.png
    """
    # Strip known extension if present to get the base name
    base_name = texture_name
    for ext in TEXTURE_EXTENSIONS:
        if texture_name.lower().endswith(ext.lower()):
            base_name = texture_name[:-len(ext)]
            break

    # Try each extension
    for ext in TEXTURE_EXTENSIONS:
        texture_path = textures_dir / f"{base_name}{ext}"
        if texture_path.exists():
            return texture_path

    # Try recursive search if not found in root
    for ext in TEXTURE_EXTENSIONS:
        for texture_path in textures_dir.rglob(f"{base_name}{ext}"):
            return texture_path

    return None


def copy_textures(
    source_textures: Path,
    output_textures: Path,
    required: set[str],
    dry_run: bool,
    fallback_texture: Path | None = None,
) -> tuple[int, int, int]:
    """Copy required texture files from SourceFiles/Textures to output/textures/.

    Iterates through the set of required texture names, finds each one in the
    source directory (using find_texture_file), and copies it to the output.
    Original file extensions are preserved.

    When a texture is not found and a fallback texture is provided, the fallback
    is copied with the missing texture's name. This ensures materials referencing
    generic textures (like Generic_Rock.png) still work by using the pack's main
    texture atlas as a substitute.

    Args:
        source_textures: Source textures directory (e.g., SourceFiles/Textures).
        output_textures: Destination textures directory (e.g., output/textures).
            Must already exist.
        required: Set of texture names to copy. Can include extensions or just
            stems (e.g., {"Ground_01", "Foliage_02.png"}).
        dry_run: If True, only log what would be copied without actually
            copying files.
        fallback_texture: Optional path to a fallback texture (typically the pack's
            main Texture_01.png atlas). When provided, missing textures will be
            substituted with copies of this fallback.

    Returns:
        Tuple of (textures_copied, textures_fallback, textures_missing) where:
        - textures_copied: Number of files successfully copied (or would be in dry_run)
        - textures_fallback: Number of textures substituted with fallback
        - textures_missing: Number of textures not found and no fallback available

    Example:
        >>> copied, fallback, missing = copy_textures(
        ...     Path("SourceFiles/Textures"),
        ...     Path("output/textures"),
        ...     {"Ground_01", "Trees_02"},
        ...     dry_run=False,
        ...     fallback_texture=Path("SourceFiles/Textures/Pack_Texture_01.png")
        ... )
        >>> print(f"Copied {copied}, fallback {fallback}, missing {missing}")
        Copied 2, fallback 0, missing 0
    """
    copied = 0
    fallback_count = 0
    missing = 0

    for texture_name in required:
        source_path = find_texture_file(source_textures, texture_name)

        if source_path is None:
            # Texture not found - try fallback
            if fallback_texture is not None and fallback_texture.exists():
                # Determine the destination filename
                # Strip extension from texture_name if present, use fallback's extension
                base_name = texture_name
                for ext in TEXTURE_EXTENSIONS:
                    if texture_name.lower().endswith(ext.lower()):
                        base_name = texture_name[:-len(ext)]
                        break

                # Use fallback's extension
                dest_name = base_name + fallback_texture.suffix
                dest_path = output_textures / dest_name

                if dry_run:
                    logger.info(
                        "[DRY RUN] Would copy fallback texture: %s -> %s (for missing %s)",
                        fallback_texture.name, dest_name, texture_name
                    )
                else:
                    shutil.copy2(fallback_texture, dest_path)
                    logger.debug(
                        "Copied fallback texture: %s -> %s (for missing %s)",
                        fallback_texture.name, dest_name, texture_name
                    )

                fallback_count += 1
            else:
                logger.warning("Texture not found (no fallback): %s", texture_name)
                missing += 1
            continue

        # Preserve original extension
        dest_path = output_textures / source_path.name

        if dry_run:
            logger.info("[DRY RUN] Would copy texture: %s -> %s", source_path, dest_path)
        else:
            shutil.copy2(source_path, dest_path)
            logger.debug("Copied texture: %s", source_path.name)

        copied += 1

    if fallback_count > 0:
        logger.info(
            "Copied %d textures, %d using fallback atlas, %d missing",
            copied, fallback_count, missing
        )
    else:
        logger.info("Copied %d textures, %d missing", copied, missing)

    return copied, fallback_count, missing


def copy_fbx_files(
    source_fbx_dir: Path,
    output_models_dir: Path,
    dry_run: bool,
) -> tuple[int, int]:
    """Copy FBX files from SourceFiles/FBX to output/models/, preserving structure.

    Recursively finds all .fbx files (case-insensitive) in the source directory
    and copies them to the output, preserving the subdirectory structure.
    Files that already exist with the same size are skipped.

    Args:
        source_fbx_dir: Path to SourceFiles/FBX directory containing FBX models.
        output_models_dir: Path to output/models directory. Subdirectories will
            be created as needed to preserve structure.
        dry_run: If True, only log what would be copied without actually
            copying files.

    Returns:
        Tuple of (fbx_copied, fbx_skipped) where:
        - fbx_copied: Number of FBX files copied (or would be in dry_run)
        - fbx_skipped: Number of FBX files skipped due to existing at destination
          with matching file size

    Example:
        >>> copied, skipped = copy_fbx_files(
        ...     Path("SourceFiles/FBX"),
        ...     Path("output/models"),
        ...     dry_run=False
        ... )
        >>> print(f"Copied {copied} FBX files, skipped {skipped}")
        Copied 150 FBX files, skipped 0
    """
    copied = 0
    skipped = 0

    if not source_fbx_dir.exists():
        logger.warning("FBX source directory not found: %s", source_fbx_dir)
        return 0, 0

    # Find all FBX files recursively (case-insensitive)
    fbx_files = list(source_fbx_dir.rglob("*.fbx")) + list(source_fbx_dir.rglob("*.FBX"))
    # Remove duplicates (Windows is case-insensitive)
    fbx_files = list({f.resolve(): f for f in fbx_files}.values())

    if not fbx_files:
        logger.warning("No FBX files found in: %s", source_fbx_dir)
        return 0, 0

    logger.info("Found %d FBX files to copy", len(fbx_files))

    for source_path in fbx_files:
        # Calculate relative path to preserve subdirectory structure
        relative_path = source_path.relative_to(source_fbx_dir)
        dest_path = output_models_dir / relative_path

        # Skip if destination already exists and is same size
        if dest_path.exists():
            if dest_path.stat().st_size == source_path.stat().st_size:
                logger.debug("Skipping existing FBX: %s", relative_path)
                skipped += 1
                continue

        if dry_run:
            logger.info("[DRY RUN] Would copy FBX: %s", relative_path)
            copied += 1
        else:
            # Ensure parent directory exists
            dest_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(source_path, dest_path)
            logger.debug("Copied FBX: %s", relative_path)
            copied += 1

    logger.info("Copied %d FBX files, skipped %d existing", copied, skipped)
    return copied, skipped


def run_godot_cli(
    godot_exe: Path,
    project_dir: Path,
    timeout_seconds: int,
    dry_run: bool,
) -> tuple[bool, bool, bool]:
    """Run Godot CLI in two phases: import and convert.

    This function orchestrates the Godot CLI operations needed to import
    FBX models and convert them to Godot scene files (.tscn).

    Phase 1 - Import:
        Runs: godot --headless --import --path <project_dir>
        This triggers Godot's asset import system to process all FBX files
        in the models/ directory, generating .import files and .scn resources.

    Phase 2 - Convert:
        Runs: godot --headless --script res://godot_converter.gd --path <project_dir>
        This executes the godot_converter.gd script which converts imported
        models to .tscn scene files in the meshes/ directory.

    The godot_converter.gd script is copied from the converter project to the
    output project directory before execution.

    Args:
        godot_exe: Path to Godot 4.6 executable. Must exist.
        project_dir: Path to the Godot project directory containing project.godot.
            The models/ and meshes/ directories should be present.
        timeout_seconds: Maximum time in seconds for each phase. If exceeded,
            the subprocess is terminated and timeout_occurred is set True.
        dry_run: If True, only log what would be executed without running Godot.

    Returns:
        Tuple of (import_success, convert_success, timeout_occurred) where:
        - import_success: True if Phase 1 completed with exit code 0
        - convert_success: True if Phase 2 completed with exit code 0
        - timeout_occurred: True if either phase exceeded the timeout

    Raises:
        No exceptions are raised; errors are logged and reflected in return values.

    Example:
        >>> import_ok, convert_ok, timed_out = run_godot_cli(
        ...     Path("C:/Godot/Godot.exe"),
        ...     Path("output"),
        ...     timeout_seconds=300,
        ...     dry_run=False
        ... )
        >>> if import_ok and convert_ok:
        ...     print("Conversion successful!")
    """
    if not godot_exe.exists():
        logger.error("Godot executable not found: %s", godot_exe)
        return False, False, False

    project_godot = project_dir / "project.godot"
    if not project_godot.exists():
        logger.error("project.godot not found in: %s", project_dir)
        return False, False, False

    # Copy godot_converter.gd to project directory
    script_dir = Path(__file__).parent
    converter_script = script_dir / "godot_converter.gd"
    dest_script = project_dir / "godot_converter.gd"

    if not converter_script.exists():
        logger.error("godot_converter.gd not found: %s", converter_script)
        return False, False, False

    if not dry_run:
        shutil.copy2(converter_script, dest_script)
        logger.debug("Copied godot_converter.gd to project")

    import_success = False
    convert_success = False
    timeout_occurred = False

    # Phase 1: Import
    import_cmd = [
        str(godot_exe),
        "--headless",
        "--import",
        "--path", str(project_dir),
    ]

    if dry_run:
        logger.info("[DRY RUN] Would run: %s", " ".join(import_cmd))
        import_success = True
    else:
        logger.info("Running Godot import (timeout: %ds)...", timeout_seconds)
        logger.debug("Command: %s", " ".join(import_cmd))

        try:
            start_time = time.time()
            result = subprocess.run(
                import_cmd,
                cwd=project_dir,
                capture_output=True,
                text=True,
                timeout=timeout_seconds,
            )
            elapsed = time.time() - start_time

            if result.returncode == 0:
                logger.info("Godot import completed in %.1fs", elapsed)
                import_success = True
            else:
                logger.error("Godot import failed (exit code %d)", result.returncode)
                if result.stderr:
                    logger.error("Stderr: %s", result.stderr[:1000])

        except subprocess.TimeoutExpired:
            logger.error("Godot import timed out after %ds", timeout_seconds)
            timeout_occurred = True
            return import_success, convert_success, timeout_occurred

        except Exception as e:
            logger.error("Failed to run Godot import: %s", e)
            return import_success, convert_success, timeout_occurred

    if not import_success and not dry_run:
        return import_success, convert_success, timeout_occurred

    # Phase 2: Convert
    convert_cmd = [
        str(godot_exe),
        "--headless",
        "--script", "res://godot_converter.gd",
        "--path", str(project_dir),
    ]

    if dry_run:
        logger.info("[DRY RUN] Would run: %s", " ".join(convert_cmd))
        convert_success = True
    else:
        logger.info("Running Godot converter script (timeout: %ds)...", timeout_seconds)
        logger.debug("Command: %s", " ".join(convert_cmd))

        try:
            start_time = time.time()
            result = subprocess.run(
                convert_cmd,
                cwd=project_dir,
                capture_output=True,
                text=True,
                timeout=timeout_seconds,
            )
            elapsed = time.time() - start_time

            if result.returncode == 0:
                logger.info("Godot converter completed in %.1fs", elapsed)
                convert_success = True

                # Log output for debugging
                if result.stdout:
                    for line in result.stdout.strip().split("\n"):
                        logger.debug("Godot: %s", line)
            else:
                logger.error("Godot converter failed (exit code %d)", result.returncode)
                if result.stderr:
                    logger.error("Stderr: %s", result.stderr[:1000])
                if result.stdout:
                    logger.error("Stdout: %s", result.stdout[:1000])

        except subprocess.TimeoutExpired:
            logger.error("Godot converter timed out after %ds", timeout_seconds)
            timeout_occurred = True

        except Exception as e:
            logger.error("Failed to run Godot converter: %s", e)

    return import_success, convert_success, timeout_occurred


def count_tscn_files(meshes_dir: Path) -> int:
    """Count .tscn scene files in the meshes directory.

    Recursively counts all files with the .tscn extension in the given
    directory. Used to verify the Godot converter script produced output.

    Args:
        meshes_dir: Path to the meshes/ directory to search.

    Returns:
        Number of .tscn files found, or 0 if the directory does not exist.
    """
    if not meshes_dir.exists():
        return 0
    return len(list(meshes_dir.rglob("*.tscn")))


def generate_project_godot(output_dir: Path, dry_run: bool) -> None:
    """Write project.godot with global shader uniforms.

    Args:
        output_dir: Output directory where project.godot will be written.
        dry_run: If True, only log what would be written.
    """
    project_path = output_dir / "project.godot"

    if dry_run:
        logger.info("[DRY RUN] Would write project.godot to: %s", project_path)
        return

    project_path.write_text(PROJECT_GODOT_TEMPLATE, encoding="utf-8")
    logger.info("Wrote project.godot with global shader uniforms")


def write_conversion_log(output_dir: Path, stats: ConversionStats, config: ConversionConfig) -> None:
    """Write a summary log file with all warnings and errors.

    Args:
        output_dir: Output directory where conversion_log.txt will be written.
        stats: Conversion statistics.
        config: Conversion configuration.
    """
    log_path = output_dir / "conversion_log.txt"

    lines = [
        "=" * 60,
        "Synty Shader Converter - Conversion Log",
        "=" * 60,
        f"Date: {datetime.now().isoformat()}",
        f"Unity Package: {config.unity_package}",
        f"Source Files: {config.source_files}",
        f"Output Directory: {config.output_dir}",
        f"Dry Run: {config.dry_run}",
        "",
        "Statistics:",
        f"  Materials Parsed: {stats.materials_parsed}",
        f"  Materials Generated: {stats.materials_generated}",
        f"  Textures Copied: {stats.textures_copied}",
        f"  Textures Fallback: {stats.textures_fallback}",
        f"  Textures Missing: {stats.textures_missing}",
        f"  Shaders Copied: {stats.shaders_copied}",
        f"  FBX Files Copied: {stats.fbx_copied}",
        f"  FBX Files Skipped: {stats.fbx_skipped}",
        f"  Meshes Converted: {stats.meshes_converted}",
        "",
        "Godot CLI Status:",
        f"  Import Success: {stats.godot_import_success}",
        f"  Convert Success: {stats.godot_convert_success}",
        f"  Timeout Occurred: {stats.godot_timeout_occurred}",
        "",
    ]

    if stats.warnings:
        lines.append(f"Warnings ({len(stats.warnings)}):")
        for warning in stats.warnings:
            lines.append(f"  - {warning}")
        lines.append("")

    if stats.errors:
        lines.append(f"Errors ({len(stats.errors)}):")
        for error in stats.errors:
            lines.append(f"  - {error}")
        lines.append("")

    lines.append("=" * 60)

    log_path.write_text("\n".join(lines), encoding="utf-8")
    logger.info("Wrote conversion log to: %s", log_path)


def print_summary(stats: ConversionStats) -> None:
    """Print conversion summary to console.

    Args:
        stats: Conversion statistics.
    """
    print("\n" + "=" * 60)
    print("Conversion Complete")
    print("=" * 60)
    print(f"  Materials Parsed:    {stats.materials_parsed}")
    print(f"  Materials Generated: {stats.materials_generated}")
    print(f"  Textures Copied:     {stats.textures_copied}")
    if stats.textures_fallback > 0:
        print(f"  Textures Fallback:   {stats.textures_fallback} (using pack atlas)")
    print(f"  Textures Missing:    {stats.textures_missing}")
    print(f"  Shaders Copied:      {stats.shaders_copied}")
    print(f"  FBX Files Copied:    {stats.fbx_copied}")
    if stats.fbx_skipped > 0:
        print(f"  FBX Files Skipped:   {stats.fbx_skipped} (already existed)")
    print(f"  Meshes Converted:    {stats.meshes_converted}")

    # Godot CLI status
    if stats.godot_import_success and stats.godot_convert_success:
        print("  Godot CLI:           Success")
    elif stats.godot_import_success and stats.meshes_converted > 0:
        # Meshes were converted even if script reported warnings
        print("  Godot CLI:           Success (with warnings)")
    elif stats.godot_timeout_occurred:
        print("  Godot CLI:           TIMEOUT")
    elif not stats.godot_import_success and not stats.godot_convert_success:
        print("  Godot CLI:           Skipped")
    elif not stats.godot_import_success:
        print("  Godot CLI:           Import Failed")
    elif not stats.godot_convert_success:
        print("  Godot CLI:           Conversion Failed")

    if stats.warnings:
        print(f"\n  Warnings: {len(stats.warnings)}")

    if stats.errors:
        print(f"\n  Errors: {len(stats.errors)}")
        for error in stats.errors[:5]:
            print(f"    - {error}")
        if len(stats.errors) > 5:
            print(f"    ... and {len(stats.errors) - 5} more")

    print("=" * 60 + "\n")


def run_conversion(config: ConversionConfig) -> ConversionStats:
    """Execute the full conversion pipeline.

    This is the main orchestration function that runs all conversion steps
    in sequence. The pipeline steps are:

    1. Validate inputs (already done in parse_args)
    2. Create output directory structure (shaders/, textures/, materials/, etc.)
    3. Extract Unity package and build GUID mappings
    4. Parse all .mat files from the package
    5. Detect shaders and map material properties to Godot equivalents
    6. Generate .tres material files
    7. Copy .gdshader files from the converter project
    8. Copy required textures from SourceFiles/Textures
    8.5. Copy FBX files from SourceFiles/FBX (unless --skip-fbx-copy)
    9. Parse MaterialList*.txt if present
    10. Generate mesh_material_mapping.json
    10.5. Create placeholder materials for missing references
    11. Generate project.godot with global shader uniforms
    12. Run Godot CLI to convert FBX to .tscn (unless --skip-godot-cli)

    Args:
        config: ConversionConfig instance with all required paths and options.

    Returns:
        ConversionStats populated with all metrics, warnings, and errors
        encountered during the conversion process.

    Raises:
        No exceptions are raised to the caller; all errors are captured in
        ConversionStats.errors and logged.

    Example:
        >>> config = ConversionConfig(...)
        >>> stats = run_conversion(config)
        >>> if stats.errors:
        ...     print(f"Conversion failed with {len(stats.errors)} errors")
        ... else:
        ...     print(f"Success! Generated {stats.materials_generated} materials")
    """
    stats = ConversionStats()

    # Step 1: Validate inputs (already done in parse_args, but double-check)
    logger.info("Starting conversion pipeline...")
    logger.info("  Unity Package: %s", config.unity_package)
    logger.info("  Source Files: %s", config.source_files)
    logger.info("  Output: %s", config.output_dir)

    # Step 2: Create output directory structure
    logger.info("Creating output directory structure...")
    setup_output_directories(config.output_dir, config.dry_run)

    # Step 3: Extract Unity package
    logger.info("Extracting Unity package...")
    try:
        guid_map: GuidMap = extract_unitypackage(config.unity_package)
        logger.info("Extracted %d assets from Unity package", len(guid_map.guid_to_pathname))
    except Exception as e:
        error_msg = f"Failed to extract Unity package: {e}"
        logger.error(error_msg)
        stats.errors.append(error_msg)
        return stats

    # Step 4: Parse all .mat files
    logger.info("Parsing Unity materials...")
    material_guids = get_material_guids(guid_map)
    unity_materials: list[tuple[str, UnityMaterial]] = []

    for guid in material_guids:
        content = guid_map.guid_to_content.get(guid)
        if content is None:
            warning_msg = f"No content for material GUID: {guid}"
            logger.warning(warning_msg)
            stats.warnings.append(warning_msg)
            continue

        try:
            material = parse_material_bytes(content)
            unity_materials.append((guid, material))
            stats.materials_parsed += 1
        except Exception as e:
            warning_msg = f"Failed to parse material GUID {guid}: {e}"
            logger.warning(warning_msg)
            stats.warnings.append(warning_msg)

    logger.info("Parsed %d Unity materials", stats.materials_parsed)

    # Step 5: Detect shaders and map properties
    logger.info("Mapping materials to Godot format...")
    mapped_materials: list[MappedMaterial] = []
    required_textures: set[str] = set()

    for guid, unity_mat in unity_materials:
        try:
            mapped = map_material(unity_mat, guid_map.texture_guid_to_name)
            mapped_materials.append(mapped)

            # Collect required textures
            for texture_name in mapped.textures.values():
                required_textures.add(texture_name)

        except Exception as e:
            warning_msg = f"Failed to map material '{unity_mat.name}': {e}"
            logger.warning(warning_msg)
            stats.warnings.append(warning_msg)

    logger.info("Mapped %d materials, requiring %d textures", len(mapped_materials), len(required_textures))

    # Step 6: Generate .tres files
    logger.info("Generating Godot .tres material files...")
    materials_dir = config.output_dir / "materials"

    for mapped_mat in mapped_materials:
        try:
            # Generate .tres content
            tres_content = generate_tres(
                mapped_mat,
                shader_base="res://shaders",
                texture_base="res://textures"
            )

            # Sanitize filename
            filename = sanitize_filename(mapped_mat.name) + ".tres"
            output_path = materials_dir / filename

            if config.dry_run:
                logger.info("[DRY RUN] Would write material: %s", output_path)
            else:
                write_tres_file(tres_content, output_path)
                logger.debug("Wrote material: %s", filename)

            stats.materials_generated += 1

        except Exception as e:
            warning_msg = f"Failed to generate .tres for '{mapped_mat.name}': {e}"
            logger.warning(warning_msg)
            stats.warnings.append(warning_msg)

    logger.info("Generated %d .tres material files", stats.materials_generated)

    # Step 7: Copy .gdshader files
    logger.info("Copying shader files...")
    stats.shaders_copied = copy_shaders(
        config.source_files,  # Not actually used - we use script directory
        config.output_dir,
        config.dry_run,
    )

    # Step 8: Copy required textures
    logger.info("Copying texture files...")
    source_textures = config.source_files / "Textures"
    output_textures = config.output_dir / "textures"

    # Find fallback texture (pack's main atlas) for missing generic textures
    fallback_texture = find_fallback_texture(source_textures)
    if fallback_texture:
        logger.info("Using fallback texture for missing generics: %s", fallback_texture.name)
    else:
        logger.warning("No fallback texture found - missing textures will not be substituted")

    stats.textures_copied, stats.textures_fallback, stats.textures_missing = copy_textures(
        source_textures,
        output_textures,
        required_textures,
        config.dry_run,
        fallback_texture,
    )

    # Step 8.5: Copy FBX files
    if not config.skip_fbx_copy:
        logger.info("Copying FBX files...")
        source_fbx = config.source_files / "FBX"
        output_models = config.output_dir / "models"

        stats.fbx_copied, stats.fbx_skipped = copy_fbx_files(
            source_fbx,
            output_models,
            config.dry_run,
        )

        if stats.fbx_copied == 0 and stats.fbx_skipped == 0:
            warning_msg = f"No FBX files found in {source_fbx}"
            stats.warnings.append(warning_msg)
    else:
        logger.info("Skipping FBX copy (--skip-fbx-copy)")

    # Step 9: Parse MaterialList*.txt (if exists)
    material_list_files = list(config.source_files.glob("MaterialList*.txt"))
    if material_list_files:
        material_list_path = material_list_files[0]  # Use first match
        logger.info("Parsing %s...", material_list_path.name)
        try:
            prefabs = parse_material_list(material_list_path)

            # Step 10: Generate mesh_material_mapping.json
            mapping_output = config.output_dir / "mesh_material_mapping.json"
            if config.dry_run:
                logger.info("[DRY RUN] Would write mesh_material_mapping.json")
            else:
                generate_mesh_material_mapping_json(prefabs, mapping_output)
                logger.info("Generated mesh_material_mapping.json")

            # Step 10.5: Generate placeholder materials for missing references
            logger.info("Checking for missing material references...")
            materials_dir = config.output_dir / "materials"
            existing_materials = {f.stem for f in materials_dir.glob("*.tres")}

            # Collect all referenced materials from prefabs
            # Structure: prefab -> meshes -> slots -> material_name
            referenced_materials: set[str] = set()
            for prefab in prefabs:
                for mesh in prefab.meshes:
                    for slot in mesh.slots:
                        if slot.material_name:
                            referenced_materials.add(slot.material_name)

            # Find missing materials
            missing_materials = referenced_materials - existing_materials

            if missing_materials:
                logger.info(
                    "Found %d missing material(s), resolving...",
                    len(missing_materials)
                )
                from shader_mapping import create_placeholder_material, detect_shader_type
                from tres_generator import generate_and_write_tres
                import shutil

                # Build a map of existing materials by shader type
                # So we can find similar materials for missing ones
                materials_by_shader: dict[str, list[str]] = {}
                for mat_file in materials_dir.glob("*.tres"):
                    # Read first few lines to find shader reference
                    try:
                        content = mat_file.read_text(encoding="utf-8")
                        for line in content.split("\n"):
                            if "res://shaders/" in line:
                                shader = line.split("res://shaders/")[1].split('"')[0]
                                if shader not in materials_by_shader:
                                    materials_by_shader[shader] = []
                                materials_by_shader[shader].append(mat_file.stem)
                                break
                    except Exception:
                        pass

                for mat_name in sorted(missing_materials):
                    if config.dry_run:
                        logger.info("[DRY RUN] Would resolve missing material: %s", mat_name)
                        continue

                    # Detect what shader this material should use based on its name
                    target_shader = detect_shader_type("", mat_name)

                    # Try to find an existing material with the same shader
                    similar_materials = materials_by_shader.get(target_shader, [])

                    if similar_materials:
                        # Use the first similar material as a substitute
                        # Copy it with the missing material's name
                        source_name = similar_materials[0]
                        source_path = materials_dir / f"{source_name}.tres"
                        dest_path = materials_dir / f"{mat_name}.tres"

                        shutil.copy2(source_path, dest_path)
                        stats.materials_generated += 1
                        logger.info(
                            "Mapped missing material: %s -> %s (copied from %s)",
                            mat_name, target_shader, source_name
                        )
                    else:
                        # No similar material exists, generate placeholder
                        placeholder = create_placeholder_material(mat_name)
                        generate_and_write_tres(placeholder, materials_dir)
                        stats.materials_generated += 1
                        logger.info(
                            "Generated placeholder: %s.tres -> %s (no similar material found)",
                            mat_name, placeholder.shader_file
                        )
            else:
                logger.info("All referenced materials exist")

        except Exception as e:
            warning_msg = f"Failed to parse {material_list_path.name}: {e}"
            logger.warning(warning_msg)
            stats.warnings.append(warning_msg)
    else:
        logger.info("MaterialList*.txt not found, skipping mesh-material mapping")

    # Step 11: Generate project.godot
    logger.info("Generating project.godot...")
    generate_project_godot(config.output_dir, config.dry_run)

    # Step 12: Run Godot CLI to convert FBX to .tscn scene files
    if not config.skip_godot_cli:
        logger.info("Running Godot CLI conversion...")

        (
            stats.godot_import_success,
            stats.godot_convert_success,
            stats.godot_timeout_occurred,
        ) = run_godot_cli(
            config.godot_exe,
            config.output_dir,
            config.godot_timeout,
            config.dry_run,
        )

        # Count generated .tscn files
        meshes_dir = config.output_dir / "meshes"
        stats.meshes_converted = count_tscn_files(meshes_dir)

        if stats.godot_timeout_occurred:
            error_msg = f"Godot CLI timed out after {config.godot_timeout}s"
            stats.errors.append(error_msg)
        elif not stats.godot_import_success:
            error_msg = "Godot import phase failed"
            stats.errors.append(error_msg)
        elif not stats.godot_convert_success and stats.meshes_converted == 0:
            # Only error if no meshes were converted at all
            error_msg = "Godot converter script failed"
            stats.errors.append(error_msg)
        elif stats.meshes_converted > 0:
            logger.info("Generated %d .tscn scene files", stats.meshes_converted)
        else:
            logger.warning("No mesh files generated")
    else:
        logger.info("Skipping Godot CLI (--skip-godot-cli)")

    # Write conversion log (not in dry run for the log file itself)
    if not config.dry_run:
        write_conversion_log(config.output_dir, stats, config)

    return stats


def main() -> int:
    """CLI entry point.

    Returns:
        Exit code (0 for success, 1 for errors).
    """
    # Parse arguments
    try:
        config = parse_args()
    except SystemExit:
        return 1

    # Setup logging
    log_level = logging.DEBUG if config.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format="%(levelname)s: %(message)s",
    )

    # Run conversion
    try:
        stats = run_conversion(config)
    except KeyboardInterrupt:
        print("\nConversion interrupted by user.")
        return 1
    except Exception as e:
        logger.exception("Unexpected error during conversion: %s", e)
        return 1

    # Print summary
    print_summary(stats)

    # Return error code if there were critical errors
    if stats.errors:
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
